[{"content":"公元2025年11月9日不知何许时分，此站初建成，具备基础功能，日后逐渐完善\u0026hellip;\n由于仅有的有两篇WP在此之前就写好了，这里保留了其原始的日期\n","date":"2025-11-09T00:00:00Z","image":"http://localhost:1313/p/orange/111_hu_bb30991a086ab761.png","permalink":"http://localhost:1313/p/orange/","title":"orange"},{"content":"写在前面的一些话 继moectf之后打的第二场ctf比赛，前两周主要做了cry和逆向，后面就只做了cry了，其他方向都做不动了\u0026hellip; 这次的crypto一共24道题，大部分难度适中，没有特别繁琐的分组密码题目，相比moe，难度相差不大，或者说稍微难一点，考的东西涉及的更广，另外重要的一点就是不只有附件题，还有远程题目，趣味性相较moe确实更高，总之还是挺好玩的\nWeek 1\r唯一表示\r这道题是一个中国剩余定理的应用，由若干连续的素数恢复n，而题目中remainders给了，就是c 由c的长度等于used_primes的长度，可以恢复出used_primes，那么就能用中国剩余定理求出n，即message_int\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from sympy.ntheory.modular import crt from Crypto.Util.number import long_to_bytes from gmpy2 import next_prime c = [ 1, 2, 2, 4, 0, 2, 11, 11, 8, 23, 1, 30, 35, 0, 18, 30, 55, 60, 29, 42, 8, 13, 49, 11, 69, 26, 8, 73, 84, 67, 100, 9, 77, 72, 127, 49, 57, 74, 70, 129, 146, 45, 35, 180, 196, 101, 100, 146, 100, 194, 2, 161, 35, 155 ] l = len(c) primes = [2] for i in range(l - 1): p = int(next_prime(primes[-1])) primes.append(p) reconstructed, _ = crt(primes, c) print(long_to_bytes(reconstructed)) # flag{9c8589c2-aecb-4ec4-b027-654bc322e2d1} 小跳蛙\r阅读题目源代码后，很容易就能理解在干什么，就是对一个数对(a,b)一直做运算，直到a=b 可以写出一个简单的脚本，调用五次即可拿到flag flag{Go0d_j0b_t0_Cl34r_thi5_Diff3r3nt_t45k_4_u}\n1 2 3 4 5 6 7 8 def solve(x, y): while x != y: if x \u0026gt; y: x = x - y if x \u0026lt; y: y = y - x return x, y print(solve(83934, 76854)) 初识RSA\r首先，给了key的md5值KEY = b'5ae9b7f211e23aac3df5f2b8f3b8eada'，找一个在线网站解密md5，可以得到key = b'crypto' 然后，由P和key算出p，那么就可以分解n了，注意phi(n)的计算公式即可\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from Crypto.Util.number import * import gmpy2 P = 8950704257708450266553505566662195919814660677796969745141332884563215887576312397012443714881729945084204600427983533462340628158820681332200645787691506 n = 44446616188218819786207128669544260200786245231084315865332960254466674511396013452706960167237712984131574242297631824608996400521594802041774252109118569706894250996931000927100268277762882754652796291883967540656284636140320080424646971672065901724016868601110447608443973020392152580956168514740954659431174557221037876268055284535861917524270777789465109449562493757855709667594266126482042307573551713967456278514060120085808631486752297737122542989222157016105822237703651230721732928806660755347805734140734412060262304703945060273095463889784812104712104670060859740991896998661852639384506489736605859678660859641869193937584995837021541846286340552602342167842171089327681673432201518271389316638905030292484631032669474635442148203414558029464840768382970333 c = 42481263623445394280231262620086584153533063717448365833463226221868120488285951050193025217363839722803025158955005926008972866584222969940058732766011030882489151801438753030989861560817833544742490630377584951708209970467576914455924941590147893518967800282895563353672016111485919944929116082425633214088603366618022110688943219824625736102047862782981661923567377952054731667935736545461204871636455479900964960932386422126739648242748169170002728992333044486415920542098358305720024908051943748019208098026882781236570466259348897847759538822450491169806820787193008018522291685488876743242619977085369161240842263956004215038707275256809199564441801377497312252051117441861760886176100719291068180295195677144938101948329274751595514805340601788344134469750781845 e = 65537 key = b\u0026#39;crypto\u0026#39; # 在线网站解密得到 p = P ^ (bytes_to_long(key)) q = gmpy2.isqrt(n // pow(p, 3)) phi = p * p * (p - 1) * q * (q - 1) d = pow(e, -1, phi) m = pow(c, d, n) print(long_to_bytes(m)) # flag{W3lc0me_t0_4h3_w0rl4_0f_Cryptoooo!} 随机数之旅1\r这道题是一个线性同余生成器，关系式为hint[i+1] = (a * hint[i] + message_int) mod p 其中，a，p，hint序列都已知，我们只需要利用前两个hint值就能求出明文，注意到 message_int \u0026lt; p hint[1] = (a * hint[0] + message_int) mod p hint[1] - a * hint[0] = message_int mod p\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from Crypto.Util.number import long_to_bytes a = 295789025762601408173828135835543120874436321839537374211067344874253837225114998888279895650663245853 p = 516429062949786265253932153679325182722096129240841519231893318711291039781759818315309383807387756431 hint = [ 184903644789477348923205958932800932778350668414212847594553173870661019334816268921010695722276438808, 289189387531555679675902459817169546843094450548753333994152067745494929208355954578346190342131249104, 511308006207171169525638257022520734897714346965062712839542056097960669854911764257355038593653419751, 166071289874864336172698289575695453201748407996626084705840173384834203981438122602851131719180238215, 147110858646297801442262599376129381380715215676113653296571296956264538908861108990498641428275853815, 414834276462759739846090124494902935141631458647045274550722758670850152829207904420646985446140292244 ] m = (hint[1] - a * hint[0]) % p print(long_to_bytes(m)) # flag{c3bc3ead-01e3-491b-aa2d-d2f042449fd6} Sagemath使用指哪？\r在sagemath中运行题目给的附件代码即可拿到flag flag{e142d08c-7e7d-43ed-b5ad-af51ffc512ee} 这个题实际上是在一直生成一些群，然后order()方法返回群的阶，以此来生成密钥key，进行异或加密\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # Sage 9.3 key=1 G = PSL(2, 11) key*=G.order() G = CyclicPermutationGroup(11) key*=G.order() G = AlternatingGroup(114) key*=G.order() G = PSL(4, 7) key*=G.order() G = PSU(3, 4) key*=G.order() G = MathieuGroup(12) key*=G.order() c=91550542840025722520458836108112308924742424464072171170891749838108012046397534151231852770095499011 key=(int(str(bin(key))[2:][0:42*8],2)) m=c^^key f=[] while m\u0026gt;0: x=m%256 f.append(chr(x)) m//=256 f.reverse() flag=\u0026#34;\u0026#34;.join(i for i in f ) print(flag) Week 2\r置换\r这道题考察的就是置换的概念以及运算 题目给了一个F，是一个看着很长的置换的运算 我再做这道题的时候是拿纸和笔算的\u0026hellip;感觉也挺方便，注意置换是从右往左算就行 把F算出来之后，反一下就是F的逆函数，比如说F是1映射到4，那么F逆就把4映射到1 把F逆算出来之后(找不到了\u0026hellip;)，拿脚本求一下结果 注意置换只作用一次，比如说：先处理的是a映射成b，然后处理b映射成c的时候，不能把刚才a映射成的b也映射成c，要不然就错了，这里用的是大小写的方法避免的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 c = \u0026#39;SUFK_D_SJNPHA_PARNUTDTJOI_WJHH_GACJIJTAHY_IOT_STUNP_YOU.\u0026#39; c = c.replace(\u0026#39;A\u0026#39;, \u0026#39;e\u0026#39;) c = c.replace(\u0026#39;B\u0026#39;, \u0026#39;g\u0026#39;) c = c.replace(\u0026#39;C\u0026#39;, \u0026#39;f\u0026#39;) c = c.replace(\u0026#39;D\u0026#39;, \u0026#39;a\u0026#39;) c = c.replace(\u0026#39;E\u0026#39;, \u0026#39;b\u0026#39;) c = c.replace(\u0026#39;F\u0026#39;, \u0026#39;c\u0026#39;) c = c.replace(\u0026#39;G\u0026#39;, \u0026#39;d\u0026#39;) c = c.replace(\u0026#39;H\u0026#39;, \u0026#39;l\u0026#39;) c = c.replace(\u0026#39;I\u0026#39;, \u0026#39;n\u0026#39;) c = c.replace(\u0026#39;J\u0026#39;, \u0026#39;i\u0026#39;) c = c.replace(\u0026#39;K\u0026#39;, \u0026#39;h\u0026#39;) c = c.replace(\u0026#39;L\u0026#39;, \u0026#39;k\u0026#39;) c = c.replace(\u0026#39;M\u0026#39;, \u0026#39;j\u0026#39;) c = c.replace(\u0026#39;N\u0026#39;, \u0026#39;m\u0026#39;) print(c.upper()) # SUCH_A_SIMPLE_PERMUTATION_WILL_DEFINITELY_NOT_STUMP_YOU. # flag{SUCH_A_SIMPLE_PERMUTATION_WILL_DEFINITELY_NOT_STUMP_YOU.} FHE: 0 and 1\r题目先将flag每个字符转换为8位二进制，然后生成一个大素数p，以p为基础随机生成一个大整数作为公钥，去一位一位的加密flag 注意到pk_i = p * rand_multiplier + rand_offset这里的rand_offset很小，然后前面的那部分是p的倍数，那么p就是pk_i - rand_offset的因子，我们直接尝试爆破，用gcd函数求出p\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pk = ... c = ... from Crypto.Util.number import * pk0 = pk[0] pk1 = pk[2] for i in range(1, 11): for j in range(1, 11): pk0 -= i pk1 -= j if isPrime(GCD(pk0, pk1)): print(GCD(pk0, pk1)) pk0 = pk[0] pk1 = pk[2] # p = 232705849988154546719847649732849410619 可以求出p，这里试了好多数据都可以，就是拿pk[0]和pk[1]不行，挺奇怪的 求出p以后，注意到c_i = int(bit) + small_noise + large_noise等式右边的large_noise是p的倍数，模一下p之后就没了，而small_noise是一个偶数，再模一个2也没了，那么就能根据奇偶性判断出bit了\n1 2 3 4 5 6 7 8 9 10 11 p = 232705849988154546719847649732849410619 flag = \u0026#39;\u0026#39; for ci in c: ci %= p if ci % 2 == 0: flag += \u0026#39;0\u0026#39; else: flag += \u0026#39;1\u0026#39; flag1 = [flag[i:i + 8] for i in range(0, len(flag), 8)] print(\u0026#39;\u0026#39;.join([chr(int(i, 2)) for i in flag1])) # flag{3235c1ab-6830-480f-b5e0-39be40b94a7d} RSA_revenge\r题目把flag拆成两半并分别加密，我们需要分别解密前后各一半 前半部分的操作是选取3个不同的大素数，然后素因子被随机提升到2到7的小幂次，乘起来得到n1，然后对n1进行rsa加密，输出有素因子列表、模n1、和密文 由于幂次很小，我们可以直接爆破，分解n，求出phi，即可恢复flag的前半部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from Crypto.Util.number import long_to_bytes, GCD list1 = ... n1 = ... c1 = ... e = 65537 n11 = 1 for i in range(2, 8): for j in range(2, 8): for k in range(2, 8): n11 *= list1[0]**i n11 *= list1[1]**j n11 *= list1[2]**k if n11 == n1: print(i, j, k) n11 = 1 运行后得到\n1 2 3 4 5 6 7 i, j, k = 3, 5 ,7 phi1 = list1[0]**2 * (list1[0] - 1) * list1[1]**4 * ( list1[1] - 1) * list1[2]**6 * (list1[2] - 1) d1 = pow(e, -1, phi1) m1 = pow(c1, d1, n1) print(long_to_bytes(m1)) # flag{Ooooo6_y0u_kn0w_F3rm 对于后半部分，随机选三个不同的大素数并把它们相乘得到n2 给了hint1 = pow(m, p2 * q2, n2)和hint2 = pow(m, r2, n2)，我们推导一下 $$\rm^{p \\cdot q} \\equiv h_1 \\pmod{n} \\\\\rm^r \\equiv h_2 \\pmod{n}\r$$ 对于第二个式子，由于r是n的因子，所以$m^r \\equiv h_2 \\pmod{r}$，又r是素数，由费马定理可得$m^r \\equiv m^{r-1} * m \\equiv m \\equiv h_2 \\pmod{r}$，结合$m^e \\equiv c \\pmod{n}$ -\u0026gt; $m^e \\equiv c \\pmod{r}$可得$h_2^e \\equiv c \\pmod{r}$，所以r是n2和$h_2^e -c$的公因子，那么我们就可以用gcd函数求出r 另一方面(p+q)是已知的，那么我们可以用n/r得到(p*q)，到这里，phi就可以求出来了\n1 2 3 4 5 6 7 8 r2 = GCD(n2, hint2**e - c2) phi2 = r2 - 1 p2q2 = n2 // r2 phi2 *= (p2q2 - hint3 + 1) d2 = pow(e, -1, phi2) m2 = pow(c2, d2, n2) print(long_to_bytes(m2)) # @t_and_Eu13r_v3ry_w3ll!!} 得到完整flagflag{Ooooo6_y0u_kn0w_F3rm@t_and_Eu13r_v3ry_w3ll!!}\n群论小测试\r这道题考的是对群的类型的判断，需要判断对五个群的类型就能拿到flag，有点像小跳蛙那道题，不过这道题有个好处是即使答错了也不会终止，还能继续答，并且进度也不会清0，这就有个非预期，一直盲猜Cn多试几次就能过\u0026hellip; flag{I_v3_b3c0m3_@n_e^3Rt_in_gr0up_7h30ry_@Ft3r_5o1ving_7hi5_+++bl3m!!!} 好吧，还是看一下这个题吧，给了几种类型的群\nn阶循环置换群 阿贝尔群 对称群 二面体群 四元数群 交错群 每次会输出一个n*n的表格，我们知道群是由一个集合和一种运算组成的，这个表格就是群的运算结果表 没学过群论，这些概念好多都不懂\u0026hellip;悲 ( 不过既然源代码利用了sagemath，理论上我们也可以用sagemath来判断? 阿贝尔群比较好判断，看是否满足交换律即可 后面的就要去看元素的阶和其他东西结合特定群的定义来判断了\nDLP_1\rDLP，即离散对数问题 这道题目是对flag大括号中间的内容进行了分三段的加密，关键是这一句pow(g[i],x,p[i])x是我们需要求的，而x在指数位置上，所以求x的问题就叫做离散对数问题 对于离散对数问题，我们采用经典的bsgs算法来解决 直接上脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def bsgs(a, b, m): # a ** x = b (mod m) from math import isqrt a %= m b %= m if b == 1: return 0 n = isqrt(m) + 1 value = {} an = pow(a, n, m) cur = b for q in range(n): value[cur] = q cur = cur * a % m cur = an for p in range(1, n + 2): if cur in value: return p * n - value[cur] cur = cur * an % m return -1 p = [189869646048037, 255751809593851, 216690843046819] g = [5, 3, 3] h = [78860859934701, 89478248978180, 81479747246082] m1 = bsgs(g[0], h[0], p[0]) m2 = bsgs(g[1], h[1], p[1]) m3 = bsgs(g[2], h[2], p[2]) from Crypto.Util.number import * print(long_to_bytes(m1) + long_to_bytes(m2) + long_to_bytes(m3)) # flag{I_l0v3_DLPPPPP^.^!} Week3\r欧皇的生日\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import random from secret import flag m = 2**22 a = random.randint(1, m-1) b = random.randint(1, m-1) c = random.randint(1, m-1) def Hash(x): return (a*x**2 + b*x + c) % m print(\u0026#34;Find a collision: give me two different numbers x1, x2 with Hash(x1)=Hash(x2).\u0026#34;) print(\u0026#34;Input Format: x1 x2\u0026#34;) cnt = 0 while cnt \u0026lt; 5000: data = input(\u0026#34;:\u0026#34;).strip().split() if len(data) != 2: print(\u0026#34;Need two numbers!\u0026#34;) continue try: x1, x2 = map(int, data) except: print(\u0026#34;Invalid input\u0026#34;) continue cnt += 1 x1 %= m x2 %= m if x1 != x2 and Hash(x1) == Hash(x2): print(flag) break else: print(\u0026#34;x\u0026#34;) print(Hash(x1),Hash(x2)) 一道哈希碰撞的题目，我们的目标是找到两个不同的数x1和x2使得Hash(x1)=Hash(x2)，其中Hash函数定义如下，是一个模m意义下的二次函数\n1 2 def Hash(x): return (a*x**2 + b*x + c) % m 其中m已知，为2**22，abc三个参数未知，输入会做一个模m的处理x1 %= m x2 %= m 我们先尝试几个特殊数字0，1，-1，这样尝试后可以得到a，(a+b+c)，(a-b+c)这三个数模m的值\n然后简单化简一下，就能拿到a，b，c模m的值，事实上我们从源代码里可以看到这三个数都是小于m的，其实就是求出了abc这三个数的值\n然后，推导一下 $$\ra \\cdot x_1^2 + b \\cdot x_1 + c \\equiv a \\cdot x_2^2 + b \\cdot x_2 + c \\pmod{m} \\\\\ra \\cdot (x_1 + x_2)(x_1 - x_2) + b \\cdot (x_1 - x_2) \\equiv 0 \\pmod{m}\r$$ 到这里，还不能直接把(x1-x2)给约掉，因为直接约的话模数m也得除一个gcd(m,x1-x2)\n不过我们先考虑一个简单的情况，就是gcd(m,x1-x2)=1 $$\ra \\cdot (x_1 + x_2) + b \\equiv 0 \\pmod{m} \\\\\r(x_1 + x_2) \\equiv a^{-1} \\cdot (-b) \\pmod{m}\r$$ 想要这样子顺利也很简单，我们选取x1和x2的时候注意x1-x2不是偶数就行\n下面是一组数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 c = 970212 mod m a + b + c = 1631836 mod m a - b + c = 3197842 mod m a = 1444627 b = 3411301 c = 970212 inv_a = 4028187 # a不一定有逆元，多试几次 -b = 783003 x1 + x2 = 3646297 我们取 x1 = 1823148 x2 = 1823149 # x2 - x1 = 1 flag{-----you---are----so++++lucky+++++}\nGCL\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from Crypto.Util.number import * import uuid import random flag=\u0026#34;flag{\u0026#34;+str(uuid.uuid4())+\u0026#34;}\u0026#34; m=bytes_to_long(flag.encode()) length=m.bit_length() def encrypt(m): gift=[] p=getPrime(length+1) a=random.randint(2,p-1) b=random.randint(2,p-1) s=random.randint(2,p-1) while len(gift)\u0026lt;10: s=(a*inverse(s,p)+b)%p if s!=0: gift.append(s) else: gift=[] s=random.randint(2,p-1) key=(a*inverse(s,p)+b)%p return m^key,gift c,gift=encrypt(m) print(\u0026#34;c=\u0026#34;,c) print(\u0026#34;gift=\u0026#34;,gift) \u0026#34;\u0026#34;\u0026#34; c= 18160008429568445340421193226402615775962630020115351294214303830750860843808409781742323237344243089 gift= [131865585354798388503853664204045577497186238155562615801484830104683890877181087005834317031942408283, 109059933499981578098773732552241207995570220834770592696583461488231579239704140357451421969855041379, 98201806091494704187082836852065059816140437191793644297243874711016194459625411781009291718075199135, 18757271931319533257322147585629190099147626954402651433709338855513752753972712032016018862573500407, 44414575833831572247180084691462875843855281105693674992974405001127527490917389843309074213475473796, 119230797767846495009095216222595719657467391997837145037599770904490776264420156248960485317227292047, 55025298938239176714746988606097305944000798467396224542466354530737718336537150422546120714654987068, 61108071970379547679922902146574052023820080507110885404335008795305785800023228103358713867748030391, 73121196162106845765032066055951000614569505693120119413603886103757507878101072263238094066564654117, 41442768650713930642944746020790921582963259300977583069055974755273373804142970727737438848232141888] \u0026#34;\u0026#34;\u0026#34; 这是一道线性同余生成器的题目(LCG)，但是递推式有所变化s = (a * inverse(s, p) + b) % p多了一步求逆的操作，有点像随机数1.9的升级版，思路是类似的，都是a,b,p均未知，主要从递推式入手做公式推导，有点像高中数列题目，下面推导求解a,b,p的方法(敲这公式太累了QAQ) $$\r\\text{gift}[10] = [s_1, s_2, \\dots, s_{10}] (注意这里的下标从1开始)\\\\\r\\begin{cases}\rs_{n+1} \\equiv (a \\cdot s_n^{-1} + b) \\mod p \\\\\rs_{n+2} \\equiv (a \\cdot s_{n+1}^{-1} + b) \\mod p \\\\\r\\end{cases} $$ 对这两个式子，两边同乘右边的逆元可得 $$\r\\begin{cases}\rs_{n+1} \\cdot s_{n} \\equiv a + b \\cdot s_{n} \\pmod{p} \\\\\rs_{n+2} \\cdot s_{n+1} \\equiv a + b \\cdot s_{n+1} \\pmod{p}\r\\end{cases}\r$$ 对上面第一个式子两边同乘s_n+1，第二个式子两边同乘s_n，然后做差，目的是消去带b的项 $$\r\\begin{cases}\r(s_{n+1})^2 \\cdot s_n \\equiv a \\cdot s_{n+1} + b \\cdot s_n \\cdot s_{n+1} \\pmod{p} \\\\\rs_{n+2} \\cdot s_{n+1} \\cdot s_n \\equiv a \\cdot s_n + b \\cdot s_{n+1} \\cdot s_n \\pmod{p}\\\\\r\\end{cases} \\\\\rs_{n+1} \\cdot s_n \\cdot(s_{n+2} - s_{n+1})\\equiv a (s_n - s_{n+1}) \\equiv -a (s_{n+1} - s_n) \\pmod{p}\r$$记$ t_n = s_{n+1} - s_n$，可得\n$$\r\\begin{cases}\rs_{n+1} \\cdot s_n \\cdot t_{n+2} \\equiv -at_{n+1} \\pmod{p} \\\\\rs_{n} \\cdot s_{n-1} \\cdot t_{n+1} \\equiv -at_n \\pmod{p}\r\\end{cases} \\\\\r$$ 第一个式子两边乘$s_ns_{n-1}$，然后两边同乘tn $$\rs_{n+1} \\cdot s_n \\cdot t_{n+2} \\cdot (s_ns_{n-1}) \\equiv -at_{n+1} \\cdot (s_ns_{n-1}) \\equiv -a \\cdot (-at_n) \\equiv a^2t_n \\pmod{p}\r$$ 两边同乘$t_n$ $$\rs_{n+1} \\cdot s_n \\cdot t_{n+2} \\cdot (s_ns_{n-1}) \\cdot t_n \\equiv a^2t_n^2 \\equiv (-at_n)^2 \\equiv (s_ns_{n-1}t_{n+1})^2 \\pmod{p} \\\\\r=\u003e (s_{n+1}s_n) \\cdot t_{n+2} \\cdot t_n \\equiv (s_ns_{n-1})t_{n+1}^2 \\pmod{p} \\\\\r再写一式 (s_{n+2}s_{n+1}) \\cdot t_{n+1} \\cdot t_{n+3} \\equiv (s_{n+1}s_n)t_{n+2}^2 \\pmod{p}\r$$现在两个式子中以及把a和b全消去了，剩下的全是已知量，代入n，用gcd函数即可求出p 有了p之后，求a和b就简单了，只需要代回上面的某些式子即可 具体在用gcd求p的时候，发现能求出来好几个大数，但都不是素数，但是这几个大数的公因子是p，有点奇怪\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 for i in range(2, 8): tmp1 = g[i - 1] * g[i] tmp2 = g[i] * g[i + 1] tmp3 = g[i + 1] * g[i + 2] T1 = tmp2 * t[i] * t[i + 2] - tmp1 * t[i + 1]**2 T2 = tmp3 * t[i + 1] * t[i + 3] - tmp2 * t[i + 2]**2 p = GCD(T1, T2) print(p) print(isPrime(p)) # 发现输出一系列大数，但是都不是素数 # 取了其中两个再求gcd print(GCD(401472189524218142101995883448864287482783058391244724871508835559039668303295079311080270663218422601,535296252698957522802661177931819049977044077854992966495345114078719557737726772414773694217624563468)) print(isPrime(133824063174739380700665294482954762494261019463748241623836278519679889434431693103693423554406140867)) # True，也可以多试几组数据，结果一样 剩余exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 c = 18160008429568445340421193226402615775962630020115351294214303830750860843808409781742323237344243089 g =[0,131865585354798388503853664204045577497186238155562615801484830104683890877181087005834317031942408283,109059933499981578098773732552241207995570220834770592696583461488231579239704140357451421969855041379,98201806091494704187082836852065059816140437191793644297243874711016194459625411781009291718075199135,18757271931319533257322147585629190099147626954402651433709338855513752753972712032016018862573500407,44414575833831572247180084691462875843855281105693674992974405001127527490917389843309074213475473796,119230797767846495009095216222595719657467391997837145037599770904490776264420156248960485317227292047,55025298938239176714746988606097305944000798467396224542466354530737718336537150422546120714654987068,61108071970379547679922902146574052023820080507110885404335008795305785800023228103358713867748030391,73121196162106845765032066055951000614569505693120119413603886103757507878101072263238094066564654117,41442768650713930642944746020790921582963259300977583069055974755273373804142970727737438848232141888] from Crypto.Util.number import * t = [g[i] - g[i - 1] for i in range(1, len(g))] t = [0] + t # 这里g和t都在开始加了一个0，目的是使得和推导中的下标对应上，好写代码 # p从上面的代码中求出 p = 133824063174739380700665294482954762494261019463748241623836278519679889434431693103693423554406140867 b = (g[3] * g[2] - g[2] * g[1]) * pow(g[2] - g[1], -1, p) b = b % p a = (g[2] * g[1] - b * g[1]) % p key = (a * pow(g[10], -1, p) + b) % p m = c ^ key print(long_to_bytes(m)) # flag{2eac1c79-8abd-465e-82f4-96beffed69e4} 随机数之旅3\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Sage 9.3 import random import uuid flag=\u0026#34;flag{\u0026#34;+str(uuid.uuid4())+\u0026#34;}\u0026#34; n=len(flag) m=n-1 p=random_prime(2**20) A=[random.randint(p//2,p-1) for _ in range(m*n)] A=matrix(Zmod(p),m,n,A) x=[ord(i) for i in flag] x=vector(x) b=A*x with open(\u0026#34;output.txt\u0026#34;,\u0026#34;w\u0026#34;) as f: f.write(str(p)+\u0026#34;\\n\u0026#34;) f.write(str(list(A))+\u0026#34;\\n\u0026#34;) f.write(str(list(b))) 简要分析\n1 2 3 4 5 6 7 n = len(flag) m = n-1 A = [random.randint(p//2,p-1) for _ in range(m*n)] A = matrix(Zmod(p),m,n,A) x = [ord(i) for i in flag] x = vector(x) b = A * x A是一个m*n的矩阵，x是一个n维向量，则b是一个m维向量，现已知A，b，p，我们的目标是求出x向量\n由b = A * x可构造一个方程组，有m = n - 1个方程，n个未知数，看上去是一个欠定方程组，但是其实题目给了flag的格式\u0026rsquo;flag{\u0026hellip;}\u0026lsquo;也就是说x的内容我们并非全部未知，把第一个字符\u0026rsquo;f\u0026rsquo;当成已知量，解一个(n-1)元的方程组即可\n我们把A的第一列拎出去，结合线代中矩阵和向量相乘的知识稍改一下b向量即可 exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 A = ... b = ... p = 5323 n = len(A[0]) m = n - 1 A = matrix(Zmod(p), A) t = ord(\u0026#39;f\u0026#39;) A1 = matrix(Zmod(p), m, m) for i in range(m): for j in range(m): A1[i, j] = A[i, j + 1] for i in range(len(b)): b[i] -= A[i][0] * t b = vector(Zmod(p), b) x0 = A1.solve_right(b) print(\u0026#39;f\u0026#39; + \u0026#39;\u0026#39;.join([chr(i) for i in x0])) # flag{1f59622f-ccbc-45c0-b9f5-731a51343027} CBC之舞\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import os from Crypto.Cipher import AES from Crypto.Util.Padding import pad import random BLOCK_SIZE = 16 key = os.urandom(16) iv2 = os.urandom(16) #flag为m2的部分内容 cipher = AES.new(key, AES.MODE_CBC, iv2) padded_m2 = pad(m2, AES.block_size) print(len(padded_m2)) c2 = cipher.encrypt(padded_m2) c2_blocks = [c2[i:i+16] for i in range(0, len(c2), 16)] print(len(c2_blocks)) #偶不，这段不应该被你们看见的 # perm = [1, 2, 3, 0] # random.shuffle(perm) # while any(i == perm[i] for i in range(4)): # random.shuffle(perm) c1_blocks = [c2_blocks[i] for i in perm] c1 = b\u0026#39;\u0026#39;.join(c1_blocks) iv1 = os.urandom(16) cipher = AES.new(key, AES.MODE_CBC, iv1) m1 = cipher.decrypt(c1) print(\u0026#34;IV1 (hex):\u0026#34;, iv1.hex()) print(\u0026#34;IV2 (hex):\u0026#34;, iv2.hex()) print(\u0026#34;m1 (hex):\u0026#34;, m1.hex()) print(\u0026#34;c1 (hex):\u0026#34;, c1.hex()) print(\u0026#34;c2 (hex):\u0026#34;, c2.hex()) \u0026#34;\u0026#34;\u0026#34; IV1 (hex): 1e5d251ea78ef68a1282079fd028c747 IV2 (hex): 18777ae4c1a29f4c5db8ba6c5dfe72f1 m1 (hex): f560fd28ed5c5ce7d952eb44b47007e702f42dbb54540dfc78467f48933dbb01ebcf520fd3d23a211d3b4e8c06261966cb178525c25b8058ff792e0f251d3d15 c1 (hex): caf7bc1223c17f848aec854a87b8958d4c518f7287663bfae0b6a5a1e0f0eb95b50c9ea6789a7d77fda5f50d1b8a2183b40cab693ebacf32a9b59faf3b0084ff c2 (hex): b40cab693ebacf32a9b59faf3b0084ffcaf7bc1223c17f848aec854a87b8958db50c9ea6789a7d77fda5f50d1b8a21834c518f7287663bfae0b6a5a1e0f0eb95 \u0026#34;\u0026#34;\u0026#34; 考察AES-CBC分组密码的题目，题目的意思是m2为flag明文，我们现在有AES加密后的密文c2和iv2，密钥未知 以及另一组密文c1，偏移量iv1，和用相同密钥解密的明文m1 关键在于这段代码\n1 2 3 4 5 # 偶不，这段不应该被你们看见的 perm = [1, 2, 3, 0] random.shuffle(perm) while any(i == perm[i] for i in range(4)): random.shuffle(perm) 这段代码说明c1和c2大小都是4个块，并且c1是c2的4个块的某种排列组合 这样的排列组合的特点是perm的4个索引和索引对应的值都不相等，那我们可以枚举出所有的可能情况，然后去遍历，写wp的时候突然意识到，c1和c2都知道，那我们直接比对一下不就直接确定出perm了\u0026hellip;当时还因为遍历所有情况，代码一直有bug，好吧，那么prem就是[1, 3, 2, 0] 接下来，需要对CBC模式有一些了解，这里就不具体写了，由c1和c2的对应关系直接给出公式 记明文m2 = [F0, F1, F2, F3], m1 = [A, B, C, D] $$\r\\begin{cases}\rA \\oplus \\text{iv}_1 = D(C_2[1]) \\\\\rB \\oplus C_2[1] = D(C_2[3]) \\\\\rC \\oplus C_2[3] = D(C_2[2]) \\\\\rD \\oplus C_2[2] = D(C_2[0]) \\\\\r\\end{cases} \\\\\r\\begin{cases}\rD(C_2[1]) \\oplus C_2[0] = \\text{F}_1 \\\\\rD(C_2[3]) \\oplus C_2[2] = \\text{F}_3 \\\\\rD(C_2[2]) \\oplus C_2[1] = \\text{F}_2 \\\\\rD(C_2[0]) \\oplus \\text{iv}_2 = \\text{F}_0 \\\\\r\\end{cases} $$ exp，公式写清楚后可以直接不用c1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 IV1 = bytes.fromhex(\u0026#39;1e5d251ea78ef68a1282079fd028c747\u0026#39;) IV2 = bytes.fromhex(\u0026#39;18777ae4c1a29f4c5db8ba6c5dfe72f1\u0026#39;) m1 = bytes.fromhex(\u0026#39;f560fd28ed5c5ce7d952eb44b47007e702f42dbb54540dfc78467f48933dbb01ebcf520fd3d23a211d3b4e8c06261966cb178525c25b8058ff792e0f251d3d15\u0026#39;) c2 = bytes.fromhex(\u0026#39;b40cab693ebacf32a9b59faf3b0084ffcaf7bc1223c17f848aec854a87b8958db50c9ea6789a7d77fda5f50d1b8a21834c518f7287663bfae0b6a5a1e0f0eb95\u0026#39;) c2_blocks = [c2[i:i + 16] for i in range(0, len(c2), 16)] m1_blocks = [m1[i:i + 16] for i in range(0, len(m1), 16)] def xor(s1, s2): ans = \u0026#39;\u0026#39; for i in range(len(s1)): tmp = s1[i] ^ s2[i] ans += hex(tmp)[2:].zfill(2) return bytes.fromhex(ans) prem = [1, 3, 2, 0] tmp1 = xor(m1_blocks[0], IV1) tmp2 = xor(m1_blocks[1], c2_blocks[1]) tmp3 = xor(m1_blocks[2], c2_blocks[3]) tmp4 = xor(m1_blocks[3], c2_blocks[2]) f1 = xor(tmp1, c2_blocks[0]).decode() f3 = xor(tmp2, c2_blocks[2]).decode() f2 = xor(tmp3, c2_blocks[1]).decode() f0 = xor(tmp4, IV2).decode() print(f0 + f1 + f2 + f3) # flag{cbc_dancing_1s_the_best_XD_miaowu~_wangang~} # 也可以打印看一下，f3的后面确实是有填充 被泄露的素数\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from Crypto.Util.number import * import gmpy2 nbits = 2048 p = getPrime(nbits // 2) q = getPrime(nbits // 2) n = p * q e = 65537 p_bits = int(p).bit_length() high_bit_count = int(p_bits * 2 / 3) # 682 p_high = p \u0026gt;\u0026gt; (p_bits - high_bit_count) # 342 mask = (1 \u0026lt;\u0026lt; (high_bit_count - \u0026#39;?\u0026#39;)) - 1 p_high_masked = p_high \u0026amp; mask with open(\u0026#34;public_key.pem\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(f\u0026#34;n = {n}\\ne = {e}\u0026#34;) with open(\u0026#34;partial_p.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: hex_str = hex(p_high_masked)[2:] f.write(\u0026#34;???\u0026#34; + hex_str) c = pow(bytes_to_long(flag), e, n) with open(\u0026#34;ciphertext.bin\u0026#34;, \u0026#34;wb\u0026#34;) as f: f.write(long_to_bytes(c)) 这道题目考察用Copper Smith方法恢复完整的p，附件给了四个文件\n1 2 3 4 public_key.pem 可用记事本打开，得到公钥n和e ciphertext.bin 可用010打开，拿到加密后的十六进制数据 partial_p.txt p的部分内容 the obscured prime.py 题目源代码 先简单处理一下数据\n1 2 3 4 5 6 n = 21934359804505952036862374470121480969133157443403593676896735938967557380443712142948340045099502553395200377704119756795591494784154969814547228557820800704252137319116648069964954630897500682893049024415124688093092305470777707518715866086606412935218188227137641451025015198528792875781144610650284639622563092129651357421263335843442984066367152832534441036576325851144177987730637618561519998767356432693944920792456483071919398611969079921679238886430086602278453518529089393964226042148309150493671461870755024341916271456658974034765995703658414257129652933251962572776586195115459121872074657802310744772937 e = 65537 c = \u0026#39;4A F7 F2 8F B6 E2 69 7C D4 40 03 4D 61 9E FF D173 16 81 B5 CC 5B 67 D5 AF 12 4A DE 4D 8F 73 62C7 5D 3C C4 46 4E 33 1C 5E AB C5 8B 7C 9F A7 8237 95 C2 39 A4 2F 0C EE 7D 3A C9 14 8F 06 8C D85B 95 35 71 FB F8 A7 5A CE 51 10 A6 D7 D8 CA 7006 A2 0C D7 39 03 3B CA D6 C4 54 FE BB 8B 46 BB71 C8 4F 77 A3 BD 1E DE 30 02 C7 2D 02 BD B5 D7CB 97 AF D3 CF 2D 1E BA 1B F7 F0 4C 01 F4 3C 49A1 8E 6D E7 C8 29 49 4B 8D 16 06 52 88 12 74 3AF7 2B 7F 27 7C 8E 0F AF F4 86 85 6C ED EF 5E E8D4 41 A4 7C 4C 51 B2 A8 36 69 5B 60 7A 7A D7 C1AD 35 09 1E E6 14 8E 37 A4 03 51 12 41 F1 25 F858 A2 C1 80 C3 24 F9 A1 06 7D 67 C8 96 A0 C2 C20C 58 C5 D7 E5 83 1E 8B 6E EF 1F 4B 54 60 58 E42B 42 3D 55 A2 16 05 A7 F4 02 99 AE 66 42 00 B7FC B9 DF 57 6F 71 47 3B DE A0 87 2D 86 16 00 F1\u0026#39; c1 = c.replace(\u0026#39; \u0026#39;, \u0026#39;\u0026#39;) c1 = bytes.fromhex(c1) p = \u0026#39;570845343bee39c510f3b2b7a1c95617aa6c7001854525b74c5e160eb51a2576ec857f680e64a5d6e417d2aaa2adc1387c11ec74616a5eb983c7fb554debbeed5dd7e0b8327f280fee1e66f3fc4c208e9cf6d6d43b\u0026#39; 分析题目关键部分，相关数值在后面进行了标注\n1 2 3 4 5 6 p_bits = int(p).bit_length() # 1024 high_bit_count = int(p_bits * 2 / 3) # 682 p_high = p \u0026gt;\u0026gt; (p_bits - high_bit_count) # 342 mask = (1 \u0026lt;\u0026lt; (high_bit_count - \u0026#39;?\u0026#39;)) - 1 p_high_masked = p_high \u0026amp; mask 这段代码的执行的操作是先把p右移342位，这样低342位的信息就失去了；然后和mask做一个与的操作\nhigh_bit_count - \u0026lsquo;?\u0026rsquo; 的结果一定是小于等于682的，也就是说mask是一个小于等于682的全1二进制数\n最终得到的p_high_masked就又会失去高位的一些信息，也就是说最终我们得到的是p的中间的一部分内容\n我们先看一下现在已知的p有多少位len1 = len(bin(int(p, 16))[2:])输出679，这意味着在与mask与运算时，丢失了最高的3位，那我们可以枚举这3位(注意不必从0开始枚举，因为一定有3位，所以从100开始111结束)，然后通过Copper Smith方法恢复p的其余低位\n剩余部分exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 for i in range(4, 8): i = bin(i)[2:] p1 = i + bin(int(p, 16))[2:] p1 = int(p1, 2) R.\u0026lt;x\u0026gt; = Zmod(n)[] f = (p1 \u0026lt;\u0026lt; 342) + x roots = f.small_roots(1\u0026lt;\u0026lt;342, 0.4) if roots: a = int(roots[0]) p = (p1 \u0026lt;\u0026lt; 342) + a print(n % p == 0) break q = n // p from Crypto.Util.number import * c1 = bytes_to_long(c1) phi = (p - 1) * (q - 1) d = pow(e, -1, phi) m = pow(c1, int(d), n) # 莫名其妙需要int(d) print(long_to_bytes(int(m))) # flag{wh3n_th3_m0dul3_i3_bi9_en0ugh_U_c@n_c0ns1der_u3ing_coppersmith} Week4\r随机数之旅4\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from Crypto.Util.number import getPrime from Crypto.Util.number import bytes_to_long as b2l import random import uuid p=getPrime(32) print(p) flag=\u0026#34;flag{\u0026#34;+str(uuid.uuid4())+\u0026#34;}\u0026#34; pieces=[flag[i:i+3] for i in range(0,len(flag),3)] c=[b2l(i.encode()) for i in pieces] x=[random.randint(1,p-1) for i in range(14)] for i in range(100): s=sum(c[i]*x[-14+i] for i in range(14)) x.append(s%p) print(x[-28:]) \u0026#34;\u0026#34;\u0026#34; 3028255493 [2981540507, 1806477191, 1912594455, 2801509477, 401085215, 818458584, 2397034605, 2120401989, 2008340439, 66147874, 1558789534, 2187085801, 671267991, 2930313508, 924435370, 902711250, 1226810076, 769329795, 2328739529, 1228810265, 1382003520, 1967489557, 2811050420, 1008248532, 1643249997, 639108823, 449982542, 1325050025] \u0026#34;\u0026#34;\u0026#34; 由flag的格式可知flag长度为42，故pieces和c的长度均为14，与x一致 关键在于s=sum(c[i]*x[-14+i] for i in range(14))是拿x列表的后14个元素与c列表做了一个内积~~(这个说法应该是对的吧)~~然后模p追加到x列表末尾，最后给出了x的末尾28个元素 我们把这个过程以矩阵的形式给出，最左边是一个14阶方阵，我们可以求其逆矩阵，从而恢复c向量 注意到c向量中的每一个分量都是小于p的(从其构造形式可以看出)，那么就可以忽略模p $$\r\\begin{pmatrix}\rx_0 \u0026 x_1 \u0026 x_2 \u0026 \\cdots \u0026 x_{13} \\\\\rx_1 \u0026 x_2 \u0026 x_3 \u0026 \\cdots \u0026 x_{14} \\\\\rx_2 \u0026 x_3 \u0026 x_4 \u0026 \\cdots \u0026 x_{15} \\\\\r\\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\\rx_{13} \u0026 x_{14} \u0026 x_{15} \u0026 \\cdots \u0026 x_{26}\r\\end{pmatrix}\r\\times\r\\begin{pmatrix}\rc_0 \\\\ c_1 \\\\ c_2 \\\\ \\vdots \\\\ c_{13}\r\\end{pmatrix}\r\\equiv\r\\begin{pmatrix}\rx_{14} \\\\ x_{15} \\\\ x_{16} \\\\ \\vdots \\\\ x_{27}\r\\end{pmatrix}\r\\pmod{p}\r$$ exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from Crypto.Util.number import long_to_bytes p = 3028255493 a = [2981540507, 1806477191, 1912594455, 2801509477, 401085215, 818458584,2397034605, 2120401989, 2008340439, 66147874, 1558789534, 2187085801,671267991, 2930313508, 924435370, 902711250, 1226810076, 769329795,2328739529, 1228810265, 1382003520, 1967489557, 2811050420, 1008248532, 1643249997, 639108823, 449982542, 1325050025] A = matrix(Zmod(p), 14, 14) for i in range(14): for j in range(14): A[i, j] = a[i + j] b = vector(Zmod(p), a[14:]) A_inv = A.inverse() c = A_inv * b for i in c: print(long_to_bytes(int(i)).decode(), end=\u0026#39;\u0026#39;) # flag{188a9250-bd02-4746-8ddd-a32d9c1bb11a} 不求逆矩阵，用解方程组的方法也可以的\n1 2 3 x1 = A.solve_right(b) for i in x1: print(long_to_bytes(int(i)).decode(), end=\u0026#39;\u0026#39;) 独一无二\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 # Sage 9.3 from Crypto.Util.number import bytes_to_long as b2l from Crypto.Util.Padding import pad from Crypto.Cipher import AES from sympy import prevprime import uuid import random import os d=os.urandom(16) D=b2l(d) flag = f\u0026#34;flag{{{uuid.uuid4()}}}\u0026#34; cipher=AES.new(d,AES.MODE_ECB) ct=cipher.encrypt(pad(flag.encode(),16)) print(\u0026#34;ct=\u0026#34;,ct) mes1=b\u0026#34;If you used the same random number when signing,\u0026#34; mes2=b\u0026#34; then you need to be careful.\u0026#34; e1, e2 = b2l(mes1), b2l(mes2) p=random_prime(2**128) A,B=random.randint(1,p-1),random.randint(1,p-1) E = EllipticCurve(Zmod(p),[A, B]) G=E.gens()[0] n = prevprime(E.order()) print(\u0026#34;n=\u0026#34;,n) k=random.randint(1,n-1) Q=k*G r=int(Q[0])%n k_inv = pow(k, -1, n) assert r!=0 s1 = (k_inv * (e1 + r * D)) % n s2 = (k_inv * (e2 + r * D)) % n print(\u0026#34;(r1,s1)=\u0026#34;,(r,s1)) print(\u0026#34;(r2,s2)=\u0026#34;,(r,s2)) \u0026#34;\u0026#34;\u0026#34; ct= b\u0026#39;\\xd1\\x7fR\\xdaz\\x9cT\\xb8{\\x1b\\ts\\xbcJ6#\\x16n\\xcedm\\xd6v)\\x05A3\\x87\\xc51\\xfc\\x9d#\\xe5\\xf2I@\\x91\\xc3\\x96w\\xae]\\xc3Uf\\xd1\\xee\u0026#39; n= 278302096557935581738338462024559946959 (r1,s1)= (264579573280920819291511588977260661069, 157195048165685698821267525173525379816) (r2,s2)= (264579573280920819291511588977260661069, 61286613457098845815723227657607632607) \u0026#34;\u0026#34;\u0026#34; 这是一道和椭圆曲线有关的题目E = EllipticCurve(Zmod(p),[A, B])是在构造椭圆曲线，但解题并不要求我们掌握很多这方面的知识 突破点在于对mes1和mes2两条消息签名时，用的r和k都时一样的，我们推导一下，目标是恢复出D $$\r\\begin{cases}\rs_1 \\equiv k_{\\text{inv}} \\cdot (e_1 + r \\cdot D) \\mod n \\\\\rs_2 \\equiv k_{\\text{inv}} \\cdot (e_2 + r \\cdot D) \\mod n\r\\end{cases} \\\\\r=\u003e\r\\begin{cases}\rk \\equiv s_{1\\text{inv}} \\cdot (e_1 + r \\cdot D) \\mod n \\\\\rk \\equiv s_{2\\text{inv}} \\cdot (e_2 + r \\cdot D) \\mod n\r\\end{cases} \\\\\r=\u003e\rs_{1\\text{inv}} \\cdot (e_1 + r \\cdot D) \\equiv s_{2\\text{inv}} \\cdot (e_2 + r \\cdot D) \\mod n \\\\\r=\u003e\rs_{1\\text{inv}} \\cdot e_1 - s_{2\\text{inv}} \\cdot e_2 \\equiv D \\cdot (s_{2\\text{inv}} \\cdot r - s_{1\\text{inv}} \\cdot r) \\mod n\r$$ 好的，到这里只需要两边同乘一个模逆就恢复出D了，那么问题来了，D小于n吗？只有小于才能直接拿到D 这个问题先放一放最后看，我们不妨先试试行不行(是可以的)\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from Crypto.Util.number import bytes_to_long as b2l from Crypto.Util.number import long_to_bytes from Crypto.Util.Padding import unpad from Crypto.Cipher import AES mes1 = b\u0026#34;If you used the same random number when signing,\u0026#34; mes2 = b\u0026#34; then you need to be careful.\u0026#34; e1, e2 = b2l(mes1), b2l(mes2) ct = b\u0026#39;\\xd1\\x7fR\\xdaz\\x9cT\\xb8{\\x1b\\ts\\xbcJ6#\\x16n\\xcedm\\xd6v)\\x05A3\\x87\\xc51\\xfc\\x9d#\\xe5\\xf2I@\\x91\\xc3\\x96w\\xae]\\xc3Uf\\xd1\\xee\u0026#39; n = 278302096557935581738338462024559946959 (r1, s1) = (264579573280920819291511588977260661069,157195048165685698821267525173525379816) (r2, s2) = (264579573280920819291511588977260661069,61286613457098845815723227657607632607) r = r1 s1_inv = pow(s1, -1, n) s2_inv = pow(s2, -1, n) tmp = (s1_inv * e1 - s2_inv * e2) % n tmp1 = (s2_inv - s1_inv) * r % n D = tmp * pow(tmp1, -1, n) % n d = long_to_bytes(D) cipher = AES.new(d, AES.MODE_ECB) m = cipher.decrypt(ct) print(unpad(m, 16)) # 不去填充直接打印也可以 # flag{035755ac-ba88-401d-93d3-d13607aa7387} 好的，我们再看一看D的大小的问题，我们可以求出n的比特长是128位的，d=os.urandom(16);D=b2l(d)生成16字节d，那么D小于等于128位，128,127,126\u0026hellip;都有可能，刚才我们求出的D是125位的，而且能求出flag，如果D=D_0+k*n (D_0 \u0026lt; n )的话，这里的k不会很大(或许说只有0或1两种可能)，我们也能解\n共轭迷宫\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 import numpy as np from math import sqrt, pi, cos, sin import hashlib from decimal import Decimal, getcontext class Quaternion: def __init__(self, w, x, y, z): self.w = w self.x = x self.y = y self.z = z def __mul__(self, other): w1, x1, y1, z1 = self.w, self.x, self.y, self.z w2, x2, y2, z2 = other.w, other.x, other.y, other.z w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2 x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2 y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2 z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2 return Quaternion(w, x, y, z) def inv(self): norm_sq = self.w**2 + self.x**2 + self.y**2 + self.z**2 if abs(norm_sq) \u0026lt; 1e-10: raise ValueError(\u0026#34;Cannot invert quaternion with zero norm\u0026#34;) return Quaternion(self.w / norm_sq, -self.x / norm_sq, -self.y / norm_sq, -self.z / norm_sq) def conjugate(self): return Quaternion(self.w, -self.x, -self.y, -self.z) def norm(self): getcontext().prec = 50 w = Decimal(self.w) x = Decimal(self.x) y = Decimal(self.y) z = Decimal(self.z) norm_sq = w * w + x * x + y * y + z * z n = norm_sq.sqrt() return Quaternion(w / n, x / n, y / n, z / n), norm_sq, n def __str__(self): return f\u0026#34;{self.w}+{self.x}i+{self.y}j+{self.z}k\u0026#34; def __eq__(self, other): return (abs(self.w - other.w) \u0026lt; 1e-10 and abs(self.x - other.x) \u0026lt; 1e-10 and abs(self.y - other.y) \u0026lt; 1e-10 and abs(self.z - other.z) \u0026lt; 1e-10) def generate_weak_private_key(g, angle_degrees=45): getcontext().prec = 50 x = Decimal(g.x) y = Decimal(g.y) z = Decimal(g.z) g_vector_norm = Decimal(sqrt(x**2 + y**2 + z**2)) if g_vector_norm \u0026lt; 1e-10: return Quaternion(np.cos(np.radians(angle_degrees)), np.sin(np.radians(angle_degrees)), 0, 0).norm()[0] u_x = x / g_vector_norm u_y = y / g_vector_norm u_z = z / g_vector_norm angle_rad = Decimal(angle_degrees) * Decimal(pi) / Decimal(180) half_angle = angle_rad / Decimal(2) w = Decimal(cos(float(half_angle))) sin_half = Decimal(sin(float(half_angle))) x = sin_half * u_x y = sin_half * u_y z = sin_half * u_z return Quaternion(w, x, y, z) def encode_flag(flag): flag_bytes = flag parts = [ flag_bytes[0:9], flag_bytes[9:18], flag_bytes[18:27], flag_bytes[27:36] ] print(parts) return tuple(int.from_bytes(part, \u0026#39;big\u0026#39;) for part in parts) def main(): flag = b\u0026#39;flag{REDACTED}\u0026#39; w, x, y, z = encode_flag(flag) #生成元g g = Quaternion(w, x, y, z) # print(g) print(f\u0026#39;norm_squared={g.norm()[1]}\u0026#39;) g = g.norm()[0] #Alice的私钥a a = generate_weak_private_key(g) #Alice的公钥P_A P_A = a * g * a.inv() #Bob的私钥b b = generate_weak_private_key(g, 60) #Bob的公钥P_B P_B = b * g * b.inv() #Alice计算出的共享密钥 K_Alice = a * P_B * a.inv() #Bob计算出的共享密钥 K_Bob = b * P_A * b.inv() print(f\u0026#39;Alice和Bob的共享密钥是否相等: {K_Alice==K_Bob}\u0026#39;) print(f\u0026#39;Alice的共享密钥: {K_Alice}\u0026#39;) if __name__ == \u0026#34;__main__\u0026#34;: main() \u0026#39;\u0026#39;\u0026#39; norm_squared=15960922284361974605582033637987025644912788 Alice和Bob的共享密钥是否相等: True Alice的共享密钥: 0.47292225874042030771896799291807799271678994351844+0.44018598307489329918958641928841974350737975182974i+0.54174915328248053441099670537355485876445440400706j+0.53766968708489053913141352127029842443636489064268k 化为整数的flag的第一部分后六位十进制数为271603，第二部分后六位十进制数为292847，第三部分后六位十进制数为939167，第四部分后六位十进制数为994109 \u0026#39;\u0026#39;\u0026#39; 这是一道用四元数的密钥交换协议的题目，重点是四元数一般情况下的乘法是不可交换的 分析主函数，我们的目标是要恢复g，现有的是g的范数和经过密钥交换协议计算后的相等的K_Alice和K_Bob，以及化为整数的flag的各部分的后六位十进制数(这个暂时不知道怎么用，先放一放)，调用g = g.norm()[0]将g转化为单位四元数 自然地，我们下一步要看generate_weak_private_key函数，若g_vector_norm \u0026lt; 1e-10，则返回一个只和角度有关的四元数，否则的话要和g的分量进行一系列运算。演算一下生成私钥a和b的过程，g_vector_norm \u0026lt; 1e-10应当是不成立的，因为g的四个分量w,x,y,z大小应该相差不大，我们发现生成的a和b都是单位四元数，且具有某些相似性，导致a和b的乘法是可交换的(具体验证过程(无脑展开)就不放了)，可以进一步推出a.inv()和b.inv()的乘法也是可交换的 到这里就卡住了，因为之前做乘法的时候都相当于只是在展开多项式，我们需要考虑三角函数形式下的四元数乘法 $$\rq = \\cos\\left(\\frac{\\theta}{2}\\right) + u \\sin\\left(\\frac{\\theta}{2}\\right)\r$$ 不难发现，对于a和b和g，u向量是相同的，其中θ是旋转角度，u满足 $\\|u\\| = \\sqrt{u_x^2 + u_y^2 + u_z^2} = 1$，下面是一个结论，如果两个四元数有相同的旋转轴，他们的乘积可表示为(类似于复数乘法的性质：角度相加) $$\rq_1 q_2 = \\cos\\left(\\frac{\\theta_1 + \\theta_2}{2}\\right) + u \\sin\\left(\\frac{\\theta_1 + \\theta_2}{2}\\right)\r$$ 没有具体推导验证，有机会试一下 从这里也能更清楚的看出a和b乘法是可交换的 另外一个知识点，a * g * a⁻¹称为四元数共轭作用，特殊地，如果单位四元数a的旋转轴与g的向量部分方向相同（平行），那么：a * g * a⁻¹ = g，那么由于vector_norm \u0026gt;1e-10，K = (ab) * g * (ab)⁻¹ = g 那么就可以写一个简单的exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import math from Crypto.Util.number import long_to_bytes norm_squared = 15960922284361974605582033637987025644912788 w = 0.47292225874042030771896799291807799271678994351844 x = 0.44018598307489329918958641928841974350737975182974 y = 0.54174915328248053441099670537355485876445440400706 z = 0.53766968708489053913141352127029842443636489064268 norm = math.sqrt(norm_squared) w0 = round(norm * w) x0 = round(norm * x) y0 = round(norm * y) z0 = round(norm * z) print(long_to_bytes(w0)) print(long_to_bytes(x0)) print(long_to_bytes(y0)) print(long_to_bytes(z0)) 发现输出是这样的，每个部分都缺两个字节，这是由于在计算中损失了一些精度，这也就是化为整数的flag的各部分的后六位十进制数的作用\n1 2 3 4 b\u0026#39;flag{hd\\x00\\x00\u0026#39; b\u0026#39;_U_f1nd\\x00\\x00\u0026#39; b\u0026#39;uT_@bot\\x00\\x00\u0026#39; b\u0026#39;tr1ck?T\\x00\\x00\u0026#39; 稍加修改\n1 2 3 4 5 6 flag1 = [271603, 292847, 939167, 994109] print(long_to_bytes(w0 - w0 % 1000000 + flag1[0])) print(long_to_bytes(x0 - x0 % 1000000 + flag1[1])) print(long_to_bytes(y0 - y0 % 1000000 + flag1[2])) print(long_to_bytes(z0 - z0 % 1000000 + flag1[3])) # flag{hav3_U_f1nd_ouT_@bout_tr1ck?XD} 个人感觉如果不懂四元数确实不好做，通过这个题了解到一些皮毛，还得再仔细研究研究\u0026hellip;\n天虫的秘密\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from Crypto.Util.Padding import pad,unpad from Crypto.Cipher import AES from secret import FLAG import base64 import os KEY=os.urandom(16) iv1=os.urandom(16) cipher=AES.new(KEY,AES.MODE_CBC,iv=iv1) ct=cipher.encrypt(pad(FLAG,16)) print(base64.b64encode(iv1+ct)) def oracle(data_b64: bytes) -\u0026gt; bytes: try: data = base64.b64decode(data_b64.strip()) if len(data) \u0026lt; 32 or len(data) % 16 != 0: return b\u0026#39;ERR1\\n\u0026#39; iv = data[:16] ct = data[16:] cipher = AES.new(KEY, AES.MODE_CBC, iv) pt = cipher.decrypt(ct) try: unpad(pt, 16) return b\u0026#39;OK\\n\u0026#39; except ValueError: return b\u0026#39;ERR2\\n\u0026#39; except Exception: return b\u0026#39;ERR3\\n\u0026#39; while True: tries=input(\u0026#34;Enter what you want to try, format: base64(iv+ct)\\n\u0026#34;) if tries==\u0026#34;q\u0026#34;: break else: print(oracle(tries)) 和AES的填充有关的一道题目，查了查，发现是一个叫Padding oracle的攻击手法，参考博客，里面的原理讲的很清楚，看完就懂这道题应该怎么做了，核心就是利用服务器的反馈，使得我们知道去填充是否成功，去逐字节爆破aes解密后的中间值(不是明文)，进一步恢复明文 恍然大悟，天虫指的是填充\n下面是实现的一个exp，最后的输出有点多，可以把39行的print(res)注释掉，更简洁\n不得不提的是，我在循环调用padding_oracle_attack时，每次都会去重新连一次远程，如果服务器端flag是动态的，那么可能会出问题，幸运的是这个题flag是固定的，我想去改这个点，一方面由于pwntools使用不熟练，另一方面一改就有bug，实在改不动了，遂放弃了，就使用这个版本了(\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 from pwn import * import base64 def func1(mid_m, tmp_i): l = len(mid_m) tmp = l + 1 for t in range(l): tmp_i[t] = mid_m[t] ^ tmp return tmp_i def padding_oracle_attack(count): io = remote(\u0026#39;8.147.132.32\u0026#39;, 17242) line1 = io.recvline().strip() data_b64 = line1[2:-1] print(f\u0026#34;Base64 data: {data_b64}\u0026#34;) io.recvuntil(b\u0026#34;base64(iv+ct)\\n\u0026#34;) original_data = base64.b64decode(data_b64) iv = original_data[:16] ct_blocks = [ original_data[i:i + 16] for i in range(16, len(original_data), 16) ] print(f\u0026#34;IV: {iv.hex()}\u0026#34;) print(f\u0026#34;CT blocks: {len(ct_blocks)}\u0026#34;) print(ct_blocks) c_tmp = ct_blocks[count] test_iv = bytearray(16) mid_m = [] tmp_i = [] for j in range(15, -1, -1): for i in range(255): test_iv[j] = i send = bytes(test_iv) + c_tmp io.sendline(base64.b64encode(send)) res = io.recvline() io.recvline() if b\u0026#39;OK\u0026#39; in res: tmp_i.append(i) print(res) break tmp = i ^ (16 - j) mid_m.append(tmp) tmp_i = func1(mid_m, tmp_i) tmp1 = len(tmp_i) for k in range(tmp1): test_iv[-1 - k] = tmp_i[k] mid_m.reverse() if count == 0: ans = [chr(mid_m[i] ^ iv[i]) for i in range(16)] else: ans = [chr(mid_m[i] ^ ct_blocks[count - 1][i]) for i in range(16)] print(\u0026#39;\u0026#39;.join(ans)) for i in range(3): padding_oracle_attack(i) # flag{92a347e1-e485-40e6-b96d-b8d9cfbf14fe} 三重密钥锁\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import random from Crypto.Util.number import * from sage.all import * def encode_flag_to_abc(flag): flag_bytes = flag.encode() third = len(flag_bytes) // 3 a_bytes = flag_bytes[:third] b_bytes = flag_bytes[third:2 * third] c_bytes = flag_bytes[2 * third:] a = bytes_to_long(a_bytes) b = bytes_to_long(b_bytes) c = bytes_to_long(c_bytes) return a, b, c p = random_prime(2 ^ 512, lbound=2 ^ 511) # 512位素数 bitsize = 128 a, b, c = encode_flag_to_abc(flag) assert a \u0026lt; 2 ^ bitsize and b \u0026lt; 2 ^ bitsize and c \u0026lt; 2 ^ bitsize k = random.randint(1, p - 1) m = random.randint(1, p - 1) n = random.randint(1, p - 1) f = (k * a + m * b + n * c) % p print(\u0026#34;=== 三重密钥锁（标量版）===\u0026#34;) print(f\u0026#34;模数 p = {p}\u0026#34;) print(f\u0026#34;系数 k = {k}\u0026#34;) print(f\u0026#34;系数 m = {m}\u0026#34;) print(f\u0026#34;系数 n = {n}\u0026#34;) print(f\u0026#34;验证值 f = {f}\u0026#34;) print(f\u0026#34;提示: a,b,c都是大约{bitsize}比特的整数\u0026#34;) \u0026#39;\u0026#39;\u0026#39; === 三重密钥锁（标量版）=== 模数 p = 10424356578148041779853991789187969944186570125402901113699573185144158488847151089093649435805832723680640302469301322004769382556869280204369016044400623 系数 k = 2016425917343526209264752974016973527106088400191647819396444997081866888816818440804306653900752825844532111319244334210470353279795203950886189568717273 系数 m = 9640575609666038466312358795458735166723157003124018050805657432015561577987823522956739610343817276374800232163184447140344754253531140765054930193240661 系数 n = 8539207304708818916453730202381072788689351891251165656488809155919585187699733568697903825636944248694317545906020707873051567183468920809837554174735591 验证值 f = 3760813688323379339493776734416231127517302841171887658445242754803946122769018586447782634756726656702581791734772105099204609201876825961922712387326893 提示: a,b,c都是大约128比特的整数 \u0026#39;\u0026#39;\u0026#39; 题目在反复提示a,b,c都是大约128比特的整数，相较于p,k\u0026hellip;这些数是较小的，这都在说明要用格的LLL算法解这道题 我们有的是f = (k * a + m * b + n * c) % p改写成等式形式 $$\rf = k \\cdot a + m \\cdot b + n \\cdot c - t \\cdot p\r$$ 一开始我构造的是这样的 $$\r(a, b, c, -t) \\times\r\\begin{pmatrix}\r1 \u0026 0 \u0026 0 \u0026 k \\\\\r0 \u0026 1 \u0026 0 \u0026 m \\\\\r0 \u0026 0 \u0026 1 \u0026 n \\\\\r0 \u0026 0 \u0026 0 \u0026 p\r\\end{pmatrix}\r= (a, b, c, f)\r$$ 在这里有一个很重要的定理，名字和具体形式都忘记了，内容就是一个格矩阵L一定有一个小向量，满足范数(即各分量平方和再开根号)小于等于$\\sqrt{n} \\cdot \\det(L)^{1/n}$，其中n为L中基向量的个数，在这里n=4，如果我们的目标向量，也就是等号右边的向量它的范数比这个界限大，那么我们是规约不出来的\n我们代入各个数据的比特位数粗略验证后发现不行，主要原因就是f太大，所以重新构造，右边不能出现f $$\rk \\cdot a + m \\cdot b + n \\cdot c - t \\cdot p - f =0 \\\\\r(a, b, c, -t, -1) \\times\r\\begin{pmatrix}\r1 \u0026 0 \u0026 0 \u0026 0 \u0026 k \\\\\r0 \u0026 1 \u0026 0 \u0026 0 \u0026 m \\\\\r0 \u0026 0 \u0026 1 \u0026 0 \u0026 n \\\\\r0 \u0026 0 \u0026 0 \u0026 1 \u0026 p \\\\\r0 \u0026 0 \u0026 0 \u0026 0 \u0026 f\r\\end{pmatrix}\r= (a, b, c, -t, 0)\r$$ 现在只需要考察一下t的大小就好了$f = k \\cdot a + m \\cdot b + n \\cdot c - t \\cdot p$由这个式子各个数字的比特位估算，t的大小和a,b,c相当，可行 接下来验证一下上面的定理是否满足，右边向量的范数大概128位，左边的行列式开五次方大概是100位，发现不行，这种情况就要进行一下简单的配方，具体做法是给L矩阵最后一列都乘一个数，这样使得行列式变大，而右边向量不变，我们这里乘2**150，规约出的最后一位是0，成功 $$\r\\begin{pmatrix}\r1 \u0026 0 \u0026 0 \u0026 0 \u0026 2^{150} \\cdot k \\\\\r0 \u0026 1 \u0026 0 \u0026 0 \u0026 2^{150} \\cdot m \\\\\r0 \u0026 0 \u0026 1 \u0026 0 \u0026 2^{150} \\cdot n \\\\\r0 \u0026 0 \u0026 0 \u0026 1 \u0026 2^{150} \\cdot p \\\\\r0 \u0026 0 \u0026 0 \u0026 0 \u0026 2^{150} \\cdot f\r\\end{pmatrix}\r$$ 到这里再看一眼最开始的四阶矩阵为什么不行，其一是不满足定理的界限，更重要的是没办法配平，改变矩阵的行列式，右边的向量也会变化 exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 p = 10424356578148041779853991789187969944186570125402901113699573185144158488847151089093649435805832723680640302469301322004769382556869280204369016044400623 k = 2016425917343526209264752974016973527106088400191647819396444997081866888816818440804306653900752825844532111319244334210470353279795203950886189568717273 m = 9640575609666038466312358795458735166723157003124018050805657432015561577987823522956739610343817276374800232163184447140344754253531140765054930193240661 n = 8539207304708818916453730202381072788689351891251165656488809155919585187699733568697903825636944248694317545906020707873051567183468920809837554174735591 f = 3760813688323379339493776734416231127517302841171887658445242754803946122769018586447782634756726656702581791734772105099204609201876825961922712387326893 A = matrix([[1, 0, 0, 0, 2**150 * k], [0, 1, 0, 0, 2**150 * m], [0, 0, 1, 0, 2**150 * n], [0, 0, 0, 1, 2**150 * p], [0, 0, 0, 0, 2**150 * f]]) a = A.LLL()[0] from Crypto.Util.number import long_to_bytes for i in a[:3]: print(long_to_bytes(abs(int(i))).decode(),end=\u0026#39;\u0026#39;) # 由于对称性，要带个绝对值转成正数 # flag{op3n_A_d007_t0_th3_w0rld_0f_latt1ce} Week5\rPoly\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def b2l(b: bytes) -\u0026gt; int: result = 0 for byte in b: result = (result \u0026lt;\u0026lt; 8) | byte return result import uuid p = random_prime(2**256) #Sage 9.3 f = f\u0026#34;flag{{{uuid.uuid4()}}}\u0026#34; x1 = f[:len(f) // 2] x2 = f[len(f) // 2:] m1 = b2l(x1.encode()) m2 = b2l(x2.encode()) c1 = (m1 ^ 19 + m1 ^ 18 + 4 * m1 ^ 17) % p c2 = (5 * m2 ^ 19 + m2 ^ 18 + 4 * m2 ^ 17) % p s = (m1 ^ 7 * m2 ^ 2 + m2) % p print((p, c1, c2, s)) \u0026#34;\u0026#34;\u0026#34; (30784558756838163538710632027143185397437897603217673077150297305544071001199, 2909317260219356685336632301474678396728564531244632916913671591997406996972, 4294738619365099885640900866122577092111906369664055461700321556058254607968, 8215705534787817006092091346252328321484153279277254569529867991109185617083) \u0026#34;\u0026#34;\u0026#34; 这个题构造了三个多项式，其中c1是关于m1的，c2是关于m2的，而s是一个二元多项式 我们的目标是求出m1和m2，但是这个题有bug，应该是数据太小的缘故，不用s多项式，直接求c1和c2的根就能出结果，之后看看预期解应该怎么做吧 exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 p, c1, c2, s = (30784558756838163538710632027143185397437897603217673077150297305544071001199,2909317260219356685336632301474678396728564531244632916913671591997406996972,4294738619365099885640900866122577092111906369664055461700321556058254607968,8215705534787817006092091346252328321484153279277254569529867991109185617083) PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(p)) f1 = x^19+x^18+4*x^17-c1 f2 = 5*x^19+x^18+4*x^17-c2 roots1 = f1.roots(multiplicities=False) roots2 = f2.roots(multiplicities=False) # 这个参数的意思是不要根的重数，我们用不上 from Crypto.Util.number import long_to_bytes for i in roots1: print(long_to_bytes(int(i))) for j in roots2: print(long_to_bytes(int(j))) # flag{3bdb2424-591a-4a92-b587-74951c8ad192} Smile盒\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class CathylinFour: def __init__(self, r, key): self.r = r self.S = (13, 11, 6, 5, 2, 7, 3, 4, 9, 0, 10, 1, 12, 15, 8, 14) self.P = (0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15) self.key = key assert len(key) == self.r + 1 def deblock(self, m): return [(m \u0026gt;\u0026gt; 12) \u0026amp; 0xF, (m \u0026gt;\u0026gt; 8) \u0026amp; 0xF, (m \u0026gt;\u0026gt; 4) \u0026amp; 0xF, m \u0026amp; 0xF] def block(self, nibbles): return (nibbles[0] \u0026lt;\u0026lt; 12) | (nibbles[1] \u0026lt;\u0026lt; 8) | (nibbles[2] \u0026lt;\u0026lt; 4) | nibbles[3] def permute_bits(self, x): bits = [(x \u0026gt;\u0026gt; (15 - i)) \u0026amp; 1 for i in range(16)] new_bits = [0] * 16 for i in range(16): new_pos = self.P[i] new_bits[new_pos] = bits[i] result = 0 for i in range(16): result = (result \u0026lt;\u0026lt; 1) | new_bits[i] return result def encrypt(self, m): p = m \u0026amp; 0xffff for t in range(self.r - 1): p = p ^ self.key[t] p = self.deblock(p) p = [self.S[i] for i in p] p = self.block(p) p = self.permute_bits(p) p = p ^ self.key[self.r - 1] p = self.deblock(p) p = [self.S[i] for i in p] p = self.block(p) c = p ^ self.key[-1] return c from secret import FLAG import random key = [random.randint(0, 0xffff) for _ in range(3)] enc = CathylinFour(2, key) print(\u0026#34;Press a number to try. Press \u0026#39;q\u0026#39; to quit. Press \u0026#39;k\u0026#39; to get flag.\u0026#34;) while 1: x = input(\u0026#34;Your input: \u0026#34;) # Tips: Your input should be 0x???? if x == \u0026#39;q\u0026#39;: print(\u0026#34;Bye.\u0026#34;) break elif x == \u0026#39;k\u0026#39;: ki = input(\u0026#34;Your key:\u0026#34;) k = int(ki, 16) if k == key[-1]: print(\u0026#34;You can smile:\u0026#34;, FLAG) break else: print(\u0026#34;Wrong. Bye.\u0026#34;) break else: a = int(x, 16) c = enc.encrypt(a) print(\u0026#34;Output:\u0026#34;, hex(c)) 这是一道对S盒差分攻击的题目，参考博客差分攻击，加密的结构类似于CIPHERFOUR结构，不过是简化版本的，因为只有3个密钥，只经过了两次S盒代换，我们的目标是求出最后一个密钥 我们先求一下题目中的S盒的差分分布表，如下，横坐标为输入差分(从上到下，从0到f)，纵坐标为输出差分(从左到右，从0到f)，求差分分布表的代码放在后面的exp中 简单看一下会发现除了左上角固定的16，第12行和第16行有两个8，8意味着输出差分有1/2的概率出现，比其他情况概率很大，具体地，输入差分为f时，输出差分为3的概率为1/2；输入差分为b时，输出差分为c的概率为1/2，这就是我们主要利用的地方\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 [16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] [0, 0, 0, 4, 0, 2, 4, 2, 0, 2, 0, 2, 0, 0, 0, 0] [0, 6, 0, 4, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0] [0, 0, 2, 0, 2, 0, 2, 2, 4, 0, 2, 0, 0, 2, 0, 0] [0, 2, 2, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 6] [0, 0, 2, 0, 2, 0, 4, 0, 0, 4, 2, 0, 2, 0, 0, 0] [0, 2, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 6, 2] [0, 2, 0, 0, 0, 2, 0, 4, 4, 2, 0, 0, 0, 2, 0, 0] [0, 0, 0, 0, 4, 0, 0, 0, 2, 0, 2, 4, 2, 0, 2, 0] [0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 2, 2, 6, 0, 2] [0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 4, 2, 0, 0, 0, 4] [0, 2, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 8, 0, 0, 2] [0, 2, 0, 0, 2, 2, 0, 2, 0, 2, 0, 4, 0, 0, 2, 0] [0, 0, 6, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 4, 0] [0, 0, 0, 0, 2, 4, 2, 0, 2, 0, 6, 0, 0, 0, 0, 0] [0, 0, 0, 8, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0] 破解思路就是构造两组数据，一组是输入差分为f(0x0000 0x000f)，另一组是输入差分为b(0x0000 0x000b)，这里以m1=0x0000, m2=0x000f为例简述，查询得到对应的密文c1，c2，然后枚举k2，得到w1，w2(c2异或k2)，计算w1和w2通过S盒的逆后的v1和v2，计算v1 xor v2 即v1和v2的差分，则u1=v1 xor k1，u2=v2 xor k1，v1和v2的差分与u1和u2的差分相等，我们就得到了u1和u2的差分，由上知，输入差分为f时，输出差分极有可能是3，我们取出满足这个条件的k2，然后类似地，求出这些k2中满足输入差分为b情况的解，相当于进一步减小范围，尽管做了两轮，输出的k2集合仍不能唯一确定，可能是0，16，32\u0026hellip;(试出来的结果)，若k2集合不为空，我们就提交集合的第一个元素，反复尝试，可以成功 exp，跑一次exp相当于交互100次，我测试的结果是大概运行两次脚本，就有其中一次能拿到flag，具体概率我也不知道，不过确实可行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def deblock(m): return [(m \u0026gt;\u0026gt; 12) \u0026amp; 0xF, (m \u0026gt;\u0026gt; 8) \u0026amp; 0xF, (m \u0026gt;\u0026gt; 4) \u0026amp; 0xF, m \u0026amp; 0xF] def block(nibbles): return (nibbles[0] \u0026lt;\u0026lt; 12) | (nibbles[1] \u0026lt;\u0026lt; 8) | ( nibbles[2] \u0026lt;\u0026lt; 4) | nibbles[3] from pwn import * def main(): S = (13, 11, 6, 5, 2, 7, 3, 4, 9, 0, 10, 1, 12, 15, 8, 14) # 求差分分布表 table = [] for i in range(16): tmp = [0] * 16 table.append(tmp) for i in range(16): for j in range(16): index = i ^ j output = S[i] ^ S[j] table[index][output] += 1 S_inv = [] for i in range(len(S)): S_inv.append(S.index(i)) io = remote(\u0026#39;39.106.48.123\u0026#39;, 37344) io.recvuntil(b\u0026#39;Your input: \u0026#39;) io.sendline(b\u0026#39;0\u0026#39;) tmp = io.recvuntil(b\u0026#39;Your input: \u0026#39;).decode() tmp1 = tmp.index(\u0026#39;\\n\u0026#39;) c1 = int(tmp[8:tmp1], 16) io.sendline(b\u0026#39;f\u0026#39;) tmp = io.recvuntil(b\u0026#39;Your input: \u0026#39;).decode() tmp1 = tmp.index(\u0026#39;\\n\u0026#39;) c2 = int(tmp[8:tmp1], 16) io.sendline(b\u0026#39;b\u0026#39;) tmp = io.recvuntil(b\u0026#39;Your input: \u0026#39;).decode() tmp1 = tmp.index(\u0026#39;\\n\u0026#39;) c3 = int(tmp[8:tmp1], 16) k2_list1 = [] for k2 in range(0xffff): w1 = deblock(c1 ^ k2) w2 = deblock(c2 ^ k2) v1 = [S_inv[i] for i in w1] v2 = [S_inv[i] for i in w2] tmp = [v1[i] ^ v2[i] for i in range(4)] if tmp[0] == 0 and tmp[1] == 0 and tmp[2] == 1 and tmp[3] == 1: k2_list1.append(k2) k2_list2 = [] for k2 in k2_list1: w1 = deblock(c1 ^ k2) w3 = deblock(c3 ^ k2) v1 = [S_inv[i] for i in w1] v3 = [S_inv[i] for i in w3] tmp = [v1[i] ^ v3[i] for i in range(4)] if tmp[0] == 1 and tmp[1] == 1 and tmp[2] == 0 and tmp[3] == 0: k2_list2.append(k2) print(len(k2_list2)) if len(k2_list2) \u0026gt; 0: key = hex(k2_list2[0]) io.sendline(b\u0026#39;k\u0026#39;) io.recvuntil(b\u0026#39;Your key:\u0026#39;) io.sendline(key.encode()) tmp = io.recvline() if b\u0026#39;You can smile\u0026#39; in tmp: print(tmp) if \u0026#39;__name__\u0026#39; == \u0026#39;__name__\u0026#39;: for i in range(100): main() # flag{Ur_awesome_4_being_able_2_successfully_find_1_high-probability_delta(?)_path!} 不给你看喵\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import random import math from secret import FLAG p=225791639467198034995070527100776477487 g=3 h=5 def round(n): a=[random.randint(1,p-1) for _ in range(n)] x=[random.randint(0,1) for _ in range(n)] t=sum(a[i]*x[i] for i in range(n)) print(a) print(t) C=[] for _ in range(n): bit=int(input(\u0026#34;Every bit: \u0026#34;)) C.append(bit) s=[random.randint(1,p-1) for _ in range(n)] print(s) S=int(input(\u0026#34;\u0026gt;\u0026#34;)) R=int(input(\u0026#34;\u0026gt;\u0026#34;)) assert R\u0026gt;S assert S==sum(s[i]*x[i] for i in range(n)) assert all(C[i]\u0026gt;1 for i in range(n)) assert math.prod(pow(C[i],s[i],p) for i in range(n))%p==pow(g,S,p)*pow(h,R,p)%p round(16) print(FLAG) 我们的目标是满足assert的四个条件，R\u0026gt;S很直白，S==sum(s[i]*x[i] for i in range(n))由于n是16，可枚举，我们直接由a和t爆破出x，那么S就能直接求出来了 下一个要求是C数组的每一个元素都要大于1，C是我们自己可控的(注意C和x没关系)，构造的C要满足第四个条件，也是这道题目的核心\n$$\r\\prod_{i=0}^{15} (C_i^{s_i} \\mod p) \\equiv \\left( g^S \\cdot h^R \\right) \\mod p\r$$朴素的想法是，给c取个比较小的数，比如都是2，然后整个式子里只有R是未知的了，求个离散对数就结束了，不过不可行，因为数太大，离散对数耗时太长 这里给出我的构造，由于S==sum(s[i]*x[i] for i in range(n))，g的S次幂可以展开如下 $$\rg^{\\sum_{i=0}^{15} s_i x_i} = g^{s_0 x_0} \\cdot g^{s_1 x_1} \\cdots g^{s_{15} x_{15}}\r$$ 利用两边的指数上都有si的特点，且xi只能取0和1，若xi取0，我们就给Ci取p-1，这样Ci的si次幂只能是正负1，取决于si的奇偶性，若xi取1，我们就给Ci取g，这样下来，g的S次幂和等号左边要么相等，要么差个负号，下面我们让h的R次幂为1，利用费马小定理，R=k*(p-1)，乘一个k是为了满足R\u0026gt;S 依旧是概率性做法，我们多试几次，只要g的S次幂和等号左边相等，就能拿到flag了(不需要很多次就能出)\nexp，没有用pwntools，需要手动复制粘贴数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import math a = [...] t = ... for i in range(2**16): i1 = bin(i)[2:].zfill(16) tmp = 0 for j in range(len(i1)): tmp += int(i1[j]) * a[j] if tmp == t: break p = 225791639467198034995070527100776477487 g = 3 h = 5 x = [int(j) for j in list(i1)] C = [] for i in x: if i == 0: C.append(p - 1) else: C.append(3) s = [...] S = sum(s[i] * x[i] for i in range(16)) print(S) # 测试，若相等，就去算一个R，就成功了 tmp = math.prod(pow(C[i], s[i], p) for i in range(16)) % p tmp1 = pow(g, S, p) % p print(tmp == tmp1) # flag{Do_u_r3a1ly_n33d_me_2_5h0w_u_2_pr0v3_7h4t_1_h4v3_it?} BLS多重签名：零的裂变\r题目太长了就不贴了，有点类似上周的共轭迷宫，如果不知道这个题考的知识点的话就确实不好做 简单说就是服务器端有一个公钥，我们自己注册两个公钥，三个公钥组成的聚合公钥必须等于服务器的固定公钥，且聚合签名验证通过 在BLS签名中，聚合公钥是通过将多个公钥（椭圆曲线上的点）相加得到的，具体地 私钥是一个大整数 sk 公钥是椭圆曲线上的一个点：PK = sk × G 若我们构造sk2=-sk1，则聚合公钥就是服务器的固定公钥，那么聚合公钥的签名自然就和服务器的固定公钥的一样了，我们可以通过\u0026rsquo;sign\u0026rsquo;命令拿到签名，然后直接利用即可\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 import json import socket from py_ecc.bls import G2ProofOfPossession as bls order = 52435875175126190479447740508185965837690552500527637822603658699938581184513 def main(): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect((\u0026#39;39.106.48.123\u0026#39;, 26282)) sock.sendall(json.dumps({\u0026#34;type\u0026#34;: \u0026#34;get_info\u0026#34;}).encode() + b\u0026#39;\\n\u0026#39;) server_info = json.loads(sock.recv(1024).decode()) server_pk = bytes.fromhex(server_info[\u0026#39;message\u0026#39;][\u0026#39;server_pk\u0026#39;]) sk1 = 111 pk1 = bls.SkToPk(sk1) sk2 = (-sk1) % order pk2 = bls.SkToPk(sk2) # 注册公钥要验证pop pop1 = bls.Sign(sk1, b\u0026#34;POP\u0026#34;) pop2 = bls.Sign(sk2, b\u0026#34;POP\u0026#34;) def register(pk, pop): sock.sendall( json.dumps({ \u0026#34;type\u0026#34;: \u0026#34;register\u0026#34;, \u0026#34;pk\u0026#34;: pk.hex(), \u0026#34;pop\u0026#34;: pop.hex() }).encode() + b\u0026#39;\\n\u0026#39;) response = json.loads(sock.recv(1024).decode()) return response register(pk1, pop1) register(pk2, pop2) sock.sendall( json.dumps({ \u0026#34;type\u0026#34;: \u0026#34;sign\u0026#34;, \u0026#34;msg\u0026#34;: \u0026#34;get_flag\u0026#34; }).encode() + b\u0026#39;\\n\u0026#39;) sig_response = json.loads(sock.recv(1024).decode()) server_sig = bytes.fromhex(sig_response[\u0026#39;message\u0026#39;]) pks_list = [pk1.hex(), pk2.hex(), server_pk.hex()] sock.sendall( json.dumps({ \u0026#34;type\u0026#34;: \u0026#34;get_flag\u0026#34;, \u0026#34;pks\u0026#34;: pks_list, \u0026#34;sig\u0026#34;: server_sig.hex() }).encode() + b\u0026#39;\\n\u0026#39;) flag_response = json.loads(sock.recv(1024).decode()) print(\u0026#34;FLAG:\u0026#34;, flag_response[\u0026#39;message\u0026#39;]) if __name__ == \u0026#34;__main__\u0026#34;: main() # flag{a53b79c7-629d-404a-89fa-4d0d8ee06b6f} 题外话，由于要装py_ecc，我用的wsl直接装不了，要用虚拟环境，记录一下 sudo apt install python3-venv python3 -m venv bls_env # 创建 source bls_env/bin/activate # 激活 pip install py-ecc\n","date":"2025-11-04T00:00:00Z","image":"http://localhost:1313/p/newstar-ctf-2025-crypto-wp/fengmian_hu_df70af7d2f9b1574.jpg","permalink":"http://localhost:1313/p/newstar-ctf-2025-crypto-wp/","title":"NewStar CTF 2025 Crypto WP"},{"content":"写在前面的一些话 这是我真正意义上参加的第一场ctf比赛，通过两个月左右的学习，实践，从零开始踏入了这扇门，有乐趣，有坐牢\u0026hellip;\u0026hellip;总之，通过moe，受益匪浅，未来再接再厉 这次moe，其实五个方向题目都去尝试做了做，最后还是觉得crypto最适合，就以此为主要方向吧，至于题目，确实对于新手友好，感觉cry于新手最好的一点就是不需要各种工具，装个python，装个vscode就能开工了，然后边做题边了解密码学知识或是数学知识 总之，这次的crypto一共19道题，大部分难度适中，多花花时间，或是借助ai，都能应付得来，有几道分组密码比较繁琐，个人不是很喜欢 : (\nCrypto入门指北\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 from Crypto.PublicKey import ElGamal from Crypto.Random import get_random_bytes, random from Crypto.Util.number import * from random import * from secret import flag def generate_elgamal_keypair(bits=512): p = getPrime(bits) for _ in range(1000): g = getRandomRange(2, 5) if pow(g, (p - 1) // 2, p) != 1: break x = randrange(2, p - 1) y = pow(g, x, p) return p, g, y, x key = generate_elgamal_keypair(bits=512) p, g, y, x = key print(\u0026#34;=== 公钥 (p, g, y) ===\u0026#34;) print(\u0026#34;p =\u0026#34;, p) print(\u0026#34;g =\u0026#34;, g) print(\u0026#34;y =\u0026#34;, y) print() k = randrange(1, p - 2) m = bytes_to_long(flag) c1 = pow(g, k, p) c2 = (m * pow(y, k, p)) % p print(\u0026#34;=== 密文 (c1, c2) ===\u0026#34;) print(\u0026#34;c1 =\u0026#34;, c1) print(\u0026#34;c2 =\u0026#34;, c2) #不小心把x输出了() print(\u0026#34;x =\u0026#34;, x) \u0026#34;\u0026#34;\u0026#34; === 公钥 (p, g, y) === p = 115409637159621449517635782553574175289667159048490149855475976576983048910448410 99894993117258279094910424033273299863589407477091830213468539451196239863 g = 2 y = 831342478336601128701462358277352159533328529138054068946707321221293164841558006 5207081449784135835711205324186662482526357834042013400765421925274271853 === 密文 (c1, c2) === c1 = 665205355305564535827536225955485652597693184131825115294046454317510856013294961 0916012490837970851191204144757409335011811874896056430105292534244732863 c2 = 231491356808152642824798171910095233144493885239903182663547597194748466341836253 3363591441216570597417789120470703548843342170567039399830377459228297983 x = 801095707808655428402095966412478447961091359656003501195114326955976122911402773 8791440961864150225798049120582540951874956255115884539333966429021004214 \u0026#34;\u0026#34;\u0026#34; 由于私钥直接输出出来了，所以直接按正常ElGamal流程解密就好了\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from Crypto.Util.number import inverse, long_to_bytes p = g = y = c1 = c2 = x = c11 = pow(c1, x, p) c11_1 = inverse(c11, p) m = (c2 * c11_1) % p m = long_to_bytes(m) print(m) # moectf{th1s_1s_y0ur_f1rst_ElG@m@l} ez_DES\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from Crypto.Cipher import DES import secrets import string flag = \u0026#39;moectf{???}\u0026#39; characters = string.ascii_letters + string.digits + string.punctuation key = \u0026#39;ezdes\u0026#39;+\u0026#39;\u0026#39;.join(secrets.choice(characters) for _ in range(3)) assert key[:5] == \u0026#39;ezdes\u0026#39; key = key.encode(\u0026#39;utf-8\u0026#39;) l = 8 def encrypt(text, key): cipher = DES.new(key, DES.MODE_ECB) padded_text = text + (l - len(text) % l) * chr(len(text)) data = cipher.encrypt(padded_text.encode(\u0026#39;utf-8\u0026#39;)) return data c = encrypt(flag, key) print(\u0026#39;c =\u0026#39;, c) # c = b\u0026#39;\\xe6\\x8b0\\xc8m\\t?\\x1d\\xf6\\x99sA\u0026gt;\\xce \\rN\\x83z\\xa0\\xdc{\\xbc\\xb8X\\xb2\\xe2q\\xa4\u0026#34;\\xfc\\x07\u0026#39; 这个加密代码使用的DES就是标准的Crypto.Cipher里面的DES，所以解密的话，只需要知道密钥就能直接调用解密函数了 能清楚地看出密钥key有8位，并且前五位已知，剩余三位来自定义好的characters，那么直接爆破密钥就好了\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import string from Crypto.Cipher import DES c = b\u0026#39;\\xe6\\x8b0\\xc8m\\t?\\x1d\\xf6\\x99sA\u0026gt;\\xce \\rN\\x83z\\xa0\\xdc{\\xbc\\xb8X\\xb2\\xe2q\\xa4\u0026#34;\\xfc\\x07\u0026#39; characters = string.ascii_letters + string.digits + string.punctuation for c1 in characters: for c2 in characters: for c3 in characters: key = (\u0026#39;ezdes\u0026#39; + c1 + c2 + c3).encode(\u0026#39;utf-8\u0026#39;) cipher = DES.new(key, DES.MODE_ECB) try: decrypted = cipher.decrypt(c).decode(\u0026#39;utf-8\u0026#39;) if \u0026#39;moectf{\u0026#39; in decrypted: print(\u0026#34;Key:\u0026#34;, key) print(\u0026#34;Flag:\u0026#34;, decrypted) exit(0) except UnicodeDecodeError: pass # moectf{_Ju5t envmEra+e.!} baby_next\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from Crypto.Util.number import * from gmpy2 import next_prime from functools import reduce from secret import flag assert len(flag) == 38 assert flag[:7] == b\u0026#39;moectf{\u0026#39; assert flag[-1:] == b\u0026#39;}\u0026#39; def main(): p = getPrime(512) q = int(reduce(lambda res, _: next_prime(res), range(114514), p)) n = p * q e = 65537 m = bytes_to_long(flag) c = pow(m, e, n) print(f\u0026#39;{n = }\u0026#39;) print(f\u0026#39;{c = }\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main() \u0026#34;\u0026#34;\u0026#34; n = 96742777571959902478849172116992100058097986518388851527052638944778038830381328778848540098201307724752598903628039482354215330671373992156290837979842156381411957754907190292238010742130674404082688791216045656050228686469536688900043735264177699512562466087275808541376525564145453954694429605944189276397 c = 17445962474813629559693587749061112782648120738023354591681532173123918523200368390246892643206880043853188835375836941118739796280111891950421612990713883817902247767311707918305107969264361136058458670735307702064189010952773013588328843994478490621886896074511809007736368751211179727573924125553940385967 \u0026#34;\u0026#34;\u0026#34; 关键代码q = int(reduce(lambda res, _: next_prime(res), range(114514), p)) 这句代码的意思就是,以p为起点,计算114514次next_prime(),结果赋给q 由于p是512位的素数,114514次next_prime()后,q并不会比p大很多,也就是说q和p很接近,有了这个信息就可以对n进行分解 由于q和p很接近,而n是p和q的乘积,所以q和p和根号n都很接近,而且p小于根号n,q大于根号n 那么我们就可以从根号n开始,寻找q,找到后就按流程解密就好\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from gmpy2 import isqrt, next_prime from Crypto.Util.number import inverse, long_to_bytes n = c = e = sqrt_n = isqrt(n) q1 = next_prime(sqrt_n) for i in range(1000000): if n % q1 == 0: print(q1) q = q1 break else: print(\u0026#34;wrong\u0026#34;) q1 = next_prime(q1) p = n // q # 需要用 // 除法,用 / 的话精度有问题 phi = (p - 1) * (q - 1) d = inverse(e, phi) m = pow(c, d, n) m = long_to_bytes(m) print(m) # moectf{vv0W_p_m1nu5_q_i5_r34l1y_sm4lI} ezBSGS\r题目 x是能够满足神秘式子$13^x = 114514 \\mod 100000000000099$的最小整数，flag内容即为x\n利用bsgs算法求解离散对数问题，放一个链接https://blog.csdn.net/qq_58207591/article/details/123954286 这里直接用了现成的bsgs脚本解题了 exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 p = 100000000000099 a = 13 b = 114514 def bsgs(a, b, m): from math import isqrt a %= m b %= m if b == 1: return 0 n = isqrt(m) + 1 value = {} an = pow(a, n, m) cur = b for q in range(n): value[cur] = q cur = cur * a % m cur = an for p in range(1, n + 2): if cur in value: return p * n - value[cur] cur = cur * an % m return -1 print(bsgs(a, b, p)) # moectf{18272162371285} 后来试了试发现a不是p的原根，不过这对bsgs求解似乎不影响\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 p = 100000000000099 a = 13 b = 114514 phi = p - 1 factors = [2, 3, 11, 19, 26581605529] # sagemath分解 for q in factors: print(pow(a, phi // q, p)) if pow(a, phi // q, p) == 1: is_primitive_root = False break else: is_primitive_root = False # a不是p的原根 ez_square\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from Crypto.Util.number import * from secret import flag assert len(flag) == 35 assert flag[:7] == b\u0026#39;moectf{\u0026#39; assert flag[-1:] == b\u0026#39;}\u0026#39; def main(): p = getPrime(512) q = getPrime(512) n = p * q e = 65537 m = bytes_to_long(flag) c = pow(m, e, n) hint = pow(p + q, 2, n) print(f\u0026#39;{n = }\u0026#39;) print(f\u0026#39;{c = }\u0026#39;) print(f\u0026#39;{hint = }\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: main() \u0026#34;\u0026#34;\u0026#34; n = 83917281059209836833837824007690691544699901753577294450739161840987816051781770716778159151802639720854808886223999296102766845876403271538287419091422744267873129896312388567406645946985868002735024896571899580581985438021613509956651683237014111116217116870686535030557076307205101926450610365611263289149 c = 69694813399964784535448926320621517155870332267827466101049186858004350675634768405333171732816667487889978017750378262941788713673371418944090831542155613846263236805141090585331932145339718055875857157018510852176248031272419248573911998354239587587157830782446559008393076144761176799690034691298870022190 hint = 5491796378615699391870545352353909903258578093592392113819670099563278086635523482350754035015775218028095468852040957207028066409846581454987397954900268152836625448524886929236711403732984563866312512753483333102094024510204387673875968726154625598491190530093961973354413317757182213887911644502704780304 \u0026#34;\u0026#34;\u0026#34; RSA类型题目,给了一个hint = pow(p + q, 2, n)额外信息,对此进行一些处理 $$\r(p + q)^2 \\equiv \\text{hint} \\pmod{n}\r$$$$\r(p + q)^2 = \\text{hint}+ k \\cdot n\r$$ 而$(p + q)^2$和n应当相差不是特别大,因此可以从k出发,通过判断$1 + k \\cdot n$是否是平方数去寻找$(p + q)^2$的值\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from gmpy2 import isqrt from Crypto.Util.number import inverse, long_to_bytes n = c = hint = for i in range(1, 100): square = i * n + hint if (isqrt(square) ** 2 == square): sqrt = isqrt(square) break else: print(\u0026#34;wrong\u0026#34;) # sqrt = p + q phi = n - sqrt + 1 e = 65537 d = inverse(e, phi) m = pow(c, d, n) m = long_to_bytes(m) print(m) # moectf{Ma7hm4t1c5_is_@_k1nd_0f_a2t} ezAES\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 from secret import flag rc = [0x12, 0x23, 0x34, 0x45, 0x56, 0x67, 0x78, 0x89, 0x9a, 0xab, 0xbc, 0xcd, 0xde, 0xef,0xf1] s_box = [ [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76], [0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0], [0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15], [0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75], [0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84], [0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf], [0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8], [0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2], [0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73], [0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb], [0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79], [0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08], [0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a], [0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e], [0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf], [0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16] ] s_box_inv = [ [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb], [0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb], [0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e], [0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25], [0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92], [0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84], [0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06], [0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b], [0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73], [0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e], [0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b], [0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4], [0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f], [0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef], [0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61], [0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d] ] def sub_bytes(grid): for i, v in enumerate(grid): grid[i] = s_box[v \u0026gt;\u0026gt; 4][v \u0026amp; 0xf] def shift_rows(grid): for i in range(4): grid[i::4] = grid[i::4][i:] + grid[i::4][:i] grid =grid[0::4]+grid[1::4]+grid[2::4]+grid[3::4] def mix_columns(grid): def mul_by_2(n): s = (n \u0026lt;\u0026lt; 1) \u0026amp; 0xff if n \u0026amp; 128: s ^= 0x1b return s def mul_by_3(n): return n ^ mul_by_2(n) def mix_column(c): return [ mul_by_2(c[0]) ^ mul_by_3(c[1]) ^ c[2] ^ c[3], # [2 3 1 1] c[0] ^ mul_by_2(c[1]) ^ mul_by_3(c[2]) ^ c[3], # [1 2 3 1] c[0] ^ c[1] ^ mul_by_2(c[2]) ^ mul_by_3(c[3]), # [1 1 2 3] mul_by_3(c[0]) ^ c[1] ^ c[2] ^ mul_by_2(c[3]), # [3 1 1 2] ] for i in range(0, 16, 4): grid[i:i + 4] = mix_column(grid[i:i + 4]) def key_expansion(grid): for i in range(10 * 4): r = grid[-4:] if i % 4 == 0: # 对上一轮最后4字节自循环、S-box置换、轮常数异或，从而计算出当前新一轮最前4字节 for j, v in enumerate(r[1:] + r[:1]): r[j] = s_box[v \u0026gt;\u0026gt; 4][v \u0026amp; 0xf] ^ (rc[i // 4] if j == 0 else 0) for j in range(4): grid.append(grid[-16] ^ r[j]) return grid def add_round_key(grid, round_key): for i in range(16): grid[i] ^= round_key[i] def encrypt(b, expanded_key): # First round add_round_key(b, expanded_key) for i in range(1, 10): sub_bytes(b) shift_rows(b) mix_columns(b) add_round_key(b, expanded_key[i * 16:]) # Final round sub_bytes(b) shift_rows(b) add_round_key(b, expanded_key[-16:]) return b def aes(key, msg): expanded = key_expansion(bytearray(key)) # Pad the message to a multiple of 16 bytes b = bytearray(msg + b\u0026#39;\\x00\u0026#39; * (16 - len(msg) % 16)) # Encrypt the message for i in range(0, len(b), 16): b[i:i + 16] = encrypt(b[i:i + 16], expanded) return bytes(b) if __name__ == \u0026#39;__main__\u0026#39;: key = b\u0026#39;Slightly different from the AES.\u0026#39; enc = aes(key, flag) print(\u0026#39;Encrypted:\u0026#39;, enc) #Encrypted: b\u0026#39;%\\x98\\x10\\x8b\\x93O\\xc7\\xf02F\\xae\\xedA\\x96\\x1b\\xf9\\x9d\\x96\\xcb\\x8bT\\r\\xd31P\\xe6\\x1a\\xa1j\\x0c\\xe6\\xc8\u0026#39; 分组密码aes题目，需要对aes加密的流程有一个大致的了解才好做 密钥是直接给了，内容也算是一点提示吧，\u0026lsquo;和标准aes略微有区别\u0026rsquo;，(具体有啥区别，写wp的时候太久远了，忘记了\u0026hellip;qaq)要解密就是要实现字节代换，行移位，列混和这几种操作的逆向操作，字节代换和行移位的逆向都比较好实现，列混合比较麻烦，不过现有的资料挺多的，拿过来改一改就能用 最后就按加密流程反过来解密\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 key = b\u0026#39;Slightly different from the AES.\u0026#39; c = b\u0026#39;%\\x98\\x10\\x8b\\x93O\\xc7\\xf02F\\xae\\xedA\\x96\\x1b\\xf9\\x9d\\x96\\xcb\\x8bT\\r\\xd31P\\xe6\\x1a\\xa1j\\x0c\\xe6\\xc8\u0026#39; rc = ... s_box = ... s_box_inv = ... def key_expansion(grid): # 复制 for i in range(10 * 4): r = grid[-4:] if i % 4 == 0: # 对上一轮最后4字节自循环、S-box置换、轮常数异或，从而计算出当前新一轮最前4字节 for j, v in enumerate(r[1:] + r[:1]): r[j] = s_box[v \u0026gt;\u0026gt; 4][v \u0026amp; 0xf] ^ (rc[i // 4] if j == 0 else 0) for j in range(4): grid.append(grid[-16] ^ r[j]) return grid expanded = key_expansion(bytearray(key)) def inv_shift_rows(grid): for i in range(4): grid[i::4] = grid[i::4][-i:] + grid[i::4][:-i] grid = grid[0::4] + grid[1::4] + grid[2::4] + grid[3::4] def inv_sub_bytes(grid): for i, v in enumerate(grid): grid[i] = s_box_inv[v \u0026gt;\u0026gt; 4][v \u0026amp; 0xf] def add_round_key(grid, round_key): for i in range(16): grid[i] ^= round_key[i] def mul(a, b): \u0026#34;\u0026#34;\u0026#34;GF(2^8) 乘法\u0026#34;\u0026#34;\u0026#34; p = 0 for i in range(8): if b \u0026amp; 1: p ^= a hi_bit_set = a \u0026amp; 0x80 a = (a \u0026lt;\u0026lt; 1) \u0026amp; 0xFF if hi_bit_set: a ^= 0x1b b \u0026gt;\u0026gt;= 1 return p def inv_mix_column(col): # 逆列混合矩阵 # [14 11 13 9] # [ 9 14 11 13] # [13 9 14 11] # [11 13 9 14] return [ mul(col[0], 14) ^ mul(col[1], 11) ^ mul(col[2], 13) ^ mul(col[3], 9), mul(col[0], 9) ^ mul(col[1], 14) ^ mul(col[2], 11) ^ mul(col[3], 13), mul(col[0], 13) ^ mul(col[1], 9) ^ mul(col[2], 14) ^ mul(col[3], 11), mul(col[0], 11) ^ mul(col[1], 13) ^ mul(col[2], 9) ^ mul(col[3], 14), ] def inv_mix_columns(grid): for i in range(0, 16, 4): grid[i:i + 4] = inv_mix_column(grid[i:i + 4]) def decrypt_block(b, expanded_key): add_round_key(b, expanded[-16:]) inv_shift_rows(b) inv_sub_bytes(b) for i in range(9, 0, -1): add_round_key(b, expanded[i * 16:(i + 1) * 16]) inv_mix_columns(b) inv_shift_rows(b) inv_sub_bytes(b) add_round_key(b, expanded[:16]) return b c = bytearray(c) for i in range(0, len(c), 16): c[i:i + 16] = decrypt_block(c[i:i + 16], expanded) print(c) # moectf{Th1s_1s_4n_E4ZY_AE5_!@#} ezlegendre\r题目(输出太长了,就不放出来了)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from Crypto.Util.number import getPrime, bytes_to_long from secret import flag p = 258669765135238783146000574794031096183 a = 144901483389896508632771215712413815934 def encrypt_flag(flag): ciphertext = [] plaintext = \u0026#39;\u0026#39;.join([bin(i)[2:].zfill(8) for i in flag]) for b in plaintext: e = getPrime(16) d = randint(1,10) n = pow(a+int(b)*d, e, p) ciphertext.append(n) return ciphertext print(encrypt_flag(flag)) 由plaintext的生成方式可以看出,这应该是一个01串,所以b要么是0,要么是1 所以n只有两种取值n = pow(a, e, p)和n = pow(a + d, e, p),生成的ciphertext是有一个许多整数组成的列表 注意到e和d的取值范围都不大,所以我们可以尝试给出所有的第一种取值方式的n,得到一个list1,然后去遍历ciphertext中的数c,如果c在list1中,那么意味着这一位的b是0,反之则是1 不过,有一个问题要注意,是否存在一种可能,使得n在两种不同取值方式下得到的最终值相等呢?这样就无法通过c来判断这一位到底是0还是1了,这种碰撞的可能性应该是极小的,我们暂时不考虑,如果能正确恢复flag那就没什么事情了\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import sympy p = 258669765135238783146000574794031096183 a = 144901483389896508632771215712413815934 primes16 = list(sympy.primerange(2**15, 2**16)) list1 = [] for e in primes16: n = pow(a, e, p) list1.append(n) path = \u0026#39;ezlegendre_output.txt\u0026#39; with open(path) as f: ciphertext = eval(f.read()) ans = \u0026#39;\u0026#39; for c in ciphertext: if c in list1: ans = ans + \u0026#39;0\u0026#39; else: ans = ans + \u0026#39;1\u0026#39; bytes_list = [int(ans[i:i + 8], 2) for i in range(0, len(ans), 8)] flag = bytes(bytes_list) print(flag) # moectf{Y0u_h@v3_ju5t_s01v3d_7h1s_pr0b13m!} ez_det\r题目(输出太长了,就不放出来了)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from random import randrange from Crypto.Util.number import * from sage.all import* from secret import flag m_blocks = [bytes_to_long(flag), 0, 0, 0, 0] p = getPrime(128) def make_mask(n, p): upper = identity_matrix(n) low = identity_matrix(n) for i in range(n-1): for j in range(i+1, n): upper[i, j] = randrange(1, p) low[j, i] = randrange(1, p) result = upper * low assert det(result) == 1 return result def matrix_to_list(mat): return [list(row) for row in mat] Noise = [[randrange(1, p) for _ in range(5)] for _ in range(4)] Noise.append(m_blocks) M = matrix(Noise) A = make_mask(5, p) C = A * M print(f\u0026#34;Noise1={Noise[:4]}\u0026#34;) print(f\u0026#34;C={matrix_to_list(C)}\u0026#34;) 分析make_mask函数，可以看出upper是一个上三角矩阵，low是一个下三角矩阵，且两个矩阵的主对角线都是1，返回的result，也就是A矩阵，是一个阶为5的方阵，A矩阵的内容没什么特别的，特殊之处是A的行列式为1 M矩阵，由Noise得来，也是一个5阶方阵，分析代码可以看出，上面的4行5列都是一些随机的数，第五行是flag和4个0 C矩阵，由A和M相乘得到，也是5阶方阵 现在，M矩阵只有左下角一个flag是未知的，其余全知道，C矩阵已知，由性质：两个矩阵的积的行列式等于两个矩阵的行列式的积,我们可以得出矩阵M的行列式 $$\rM =\\begin{pmatrix}\ra_{11} \u0026 a_{12} \u0026 a_{13} \u0026 a_{14} \u0026 a_{15} \\\\\ra_{21} \u0026 a_{22} \u0026 a_{23} \u0026 a_{24} \u0026 a_{25} \\\\\ra_{31} \u0026 a_{32} \u0026 a_{33} \u0026 a_{34} \u0026 a_{35} \\\\\ra_{41} \u0026 a_{42} \u0026 a_{43} \u0026 a_{44} \u0026 a_{45} \\\\\rflag \u0026 0 \u0026 0 \u0026 0 \u0026 0\r\\end{pmatrix}\r$$ 现以第五行展开计算M的行列式，由公式，a51即为所求 $$\r\\det(M) = a_{51}A_{51} + a_{52}A_{52} + a_{53}A_{53} + a_{54}A_{54} + a_{55}A_{55} = a_{51}A_{51}\r$$ $$\rA_{51} = (-1)^{5+1} \\cdot M_{51}\r$$ $$\r\\det(M) = a_{51}M_{51}\r$$exp\n1 2 3 4 5 6 7 8 9 10 11 12 from Crypto.Util.number import long_to_bytes Noise1 = ... C = ... C = matrix(C) M51 = matrix([row[1:5] for row in Noise1]) det_m51 = det(M51) det_m = det(C) // 1 flag = det_m // det_m51 print(long_to_bytes(flag)) # moectf{D0_Y0u_kn0w_wh@7_4_de7erm1n@n7_1s!} 杂交随机数\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from Crypto.Util.number import bytes_to_long def lfsr(data, mask): mask = mask.zfill(len(data)) res_int = int(data, base=2)^int(mask, base=2) bit = 0 while res_int \u0026gt; 0: bit ^= res_int % 2 res_int \u0026gt;\u0026gt;= 1 res = data[1:]+str(bit) return res def lcg(x, a, b, m): return (a*x+b)%m flag = b\u0026#39;moectf{???}\u0026#39; x = bin(bytes_to_long(flag))[2:].zfill(len(flag)*8) l = len(x)//2 L, R = x[:l], x[l:] b = -233 m = 1\u0026lt;\u0026lt;l for _ in range(2025): mask = R seed = int(L, base=2) L = lfsr(L, mask) R = bin(lcg(int(R, base=2), b, seed, m))[2:].zfill(l) L, R = R, L en_flag = L+R print(int(en_flag, base=2)) # en_flag = 4567941593066862873653209393990031966807270114415459425382356207107640 这道题的加密过程比较清晰，将字符串分为左右两半，用lfsr和lcg两个函数对左右两半进行2025轮处理后得到密文 lfsr中的bit相当于一个校验位，用于标志data和mask异或后的结果中1的个数的奇偶性 解密思路就是把加密流程倒过来，从最后一轮开始逆着往回推 需要特别注意的是，在利用校验位的性质时，可能构造的两个结果都能通过校验而并非唯一，因此需要一个回溯机制才能找到正确解 exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 from Crypto.Util.number import long_to_bytes en_flag_val = 4567941593066862873653209393990031966807270114415459425382356207107640 en_flag_bin = bin(en_flag_val)[2:] l = len(en_flag_bin) // 2 L = en_flag_bin[:l] R = en_flag_bin[l:] m = 1 \u0026lt;\u0026lt; l b = -233 b_ = pow(b, -1, m) def decrypt_step(l1, r1): x = l1[:-1] bit = l1[-1] possible = [] for a in [\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;]: l0 = a + x L_int = int(l0, 2) R_int = (int(r1, 2) - L_int) * b_ % m r0 = bin(R_int)[2:].zfill(l) xor_val = L_int ^ int(r0, 2) parity_bit = bin(xor_val).count(\u0026#39;1\u0026#39;) % 2 if parity_bit == int(bit): possible.append((l0, r0)) return possible stack = [] stack.append((L, R, 0)) while stack: L_cur, R_cur, step = stack.pop() if step == 2025: flag_bin = L_cur + R_cur flag_int = int(flag_bin, 2) flag = long_to_bytes(flag_int) if flag.startswith(b\u0026#39;moectf{\u0026#39;) and flag.endswith(b\u0026#39;}\u0026#39;): print(flag.decode()) break else: continue L_prev, R_prev = R_cur, L_cur pairs = decrypt_step(L_prev, R_prev) for pair in pairs: stack.append((pair[0], pair[1], step + 1)) # moectf{I5_1t_Stream0rBlock.?} 沙茶姐姐的Fufu\r题目 现在有 $N$ $(1 \\leq N \\leq 10^3)$ 只 Fufu 在沙茶姐姐的购物清单上，每只 Fufu 能且仅能购买一次，其中第 $i$ 只 Fufu 的可爱程度为 $w_i$ $(1 \\leq w_i \\leq 10^9)$，每只 Fufu 还有一个“保养难度” $c_i$ $(1 \\leq c_i \\leq 10^4)$。沙茶姐姐的精力 $M$ $(1 \\leq M \\leq 10^4)$ 有限，也就是沙茶姐姐持有的所有 Fufu 的保养难度的总和不能大于 $M$，但她又想买入总可爱度尽可能多的 Fufu。现在，她把这个问题交给了你，请你帮她算算总可爱度最多可以是多少。 形式化地，你需要求出给定的 $N$ 只 Fufu 的一个子集 $S$ 在满足 $\\sum_{i \\in S} c_i \\leq M$ 的前提下，$\\sum_{i \\in S} w_i$ 的最大值。 由于沙茶姐姐是一种多维生物，所以你需要为所有 $T$ 个平行宇宙中的沙茶姐姐解决问题，在解决所有沙茶姐姐的问题后，所有问题答案的异或和就是沙茶姐姐给你的报酬——本题Flag的内容。 输入格式 第一行一个整数 $T$。 接下来 $T$ 组数据表示每一个子问题，每组数据第一行两个整数 $N$ 和$M$，接下来 $N$ 行每行两个整数 $c_i$和$w_i$描述一个 Fufu。\n抽象一下，就是一个背包问题，M是背包的容量，ci代表装的东西的大小，wi代表装的东西的价值，目的就是求出不超过总容量的情况下，装的东西的价值的最大值，且每个物品只能装一次 这个经典的01背包问题需要用动态规划算法来求解\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def solve(filename): with open(filename, \u0026#39;r\u0026#39;) as f: lines = f.readlines() idx = 0 T = int(lines[idx].strip()) idx += 1 results = [] for _ in range(T): N, M = map(int, lines[idx].strip().split()) idx += 1 items = [] for _ in range(N): a, b = map(int, lines[idx].strip().split()) items.append((a, b)) idx += 1 dp = [[0] * (M + 1) for _ in range(N + 1)] for i in range(1, N + 1): for j in range(1, M + 1): if j \u0026lt; items[i - 1][0]: dp[i][j] = dp[i - 1][j] else: data1 = dp[i - 1][j] data2 = dp[i - 1][j - items[i - 1][0]] + items[i - 1][1] dp[i][j] = max(data1, data2) results.append(dp[N][M]) ans = 0 for res in results: ans ^= res print(ans) solve(\u0026#39;./fufu_in.txt\u0026#39;) # moectf{34765768752} happyRSA\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from Crypto.Util.number import getPrime, bytes_to_long from random import randint from sympy import totient from secret import flag def power_tower_mod(a, k, m): # a↑↑k mod m if k == 1: return a % m exp = power_tower_mod(a, k - 1, totient(m)) return pow(a, int(exp), int(m)) p = getPrime(512) q = getPrime(512) r = 123456 n = p * q e = 65537 n_phi= p+q-1 x=power_tower_mod(n_phi + 1, r, pow(n_phi, 3)) m = bytes_to_long(flag) c = pow(m, e, n) print(f\u0026#34;n = {n}\u0026#34;) print(f\u0026#34;e = {e}\u0026#34;) print(f\u0026#34;c = {c}\u0026#34;) print(f\u0026#34;x = {x}\u0026#34;) \u0026#39;\u0026#39;\u0026#39; n = 128523866891628647198256249821889078729612915602126813095353326058434117743331117354307769466834709121615383318360553158180793808091715290853250784591576293353438657705902690576369228616974691526529115840225288717188674903706286837772359866451871219784305209267680502055721789166823585304852101129034033822731 e = 65537 c = 125986017030189249606833383146319528808010980928552142070952791820726011301355101112751401734059277025967527782109331573869703458333443026446504541008332002497683482554529670817491746530944661661838872530737844860894779846008432862757182462997411607513582892540745324152395112372620247143278397038318619295886 x = 522964948416919148730075013940176144502085141572251634384238148239059418865743755566045480035498265634350869368780682933647857349700575757065055513839460630399915983325017019073643523849095374946914449481491243177810902947558024707988938268598599450358141276922628627391081922608389234345668009502520912713141 \u0026#39;\u0026#39;\u0026#39; 定义了一个指数塔，实现代码细节没细看，但是知道指数塔是怎么一回事就行，例如$2 \\uparrow\\uparrow 4 = 2^{2^{2^{2}}} = 2^{2^{4}} = 2^{16} = 65536$，注意算的时候是从上往下算 核心代码x=power_tower_mod(n_phi + 1, r, pow(n_phi, 3))，实质上就是在求(p+q)的r次指数塔模pow(n_phi, 3) $$\r(p+q) \\uparrow\\uparrow r = (p+q)^{(p+q)^{(p+q)^{...}}} = (p+q)^{k_1} = (p+q-1+1)^{k_1} $$ 二项式定理 $$\r(p+q-1+1)^{k_1} \\equiv 1 + k_1(p+q-1) + \\frac{k_1(k_1-1)}{2}(p+q-1)^2 \\pmod{(p+q-1)^3}\r$$ 同样的有 $$\rk_1 = (p+q)^{k_2} = (p+q-1+1)^{k_2} \\\\\rk_1 \\equiv 1 + k_2(p+q-1) + \\frac{k_2(k_2-1)}{2}(p+q-1)^2 \\pmod{(p+q-1)^3} $$ 代入上面的式子可得 $$\r(p+q-1+1)^{k_1} \\equiv 1 +(p+q-1)+ k_2(p+q-1)^2 \\pmod{(p+q-1)^3}\r$$ 同样的，可以把k2展开成k3再次带入，可以得到最终结果 $$\r(p+q-1+1)^{k_1} \\equiv 1 +(p+q-1)+ (p+q-1)^2 \\pmod{(p+q-1)^3} \\\\\r$$ 注意到$1 +(p+q-1)+ (p+q-1)^2 \u003c{(p+q-1)^3}$，所以$1 +(p+q-1)+ (p+q-1)^2 = x$，解一个一元二次方程就能得到p+q了\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import gmpy2 from Crypto.Util.number import long_to_bytes n = e = c = x = c1 = 1 - x a = 1 b = 1 delta = b * b - 4 * a * c1 x1 = ((-1) * b + gmpy2.isqrt(delta)) // (2 * a) # 取正根 phi = n - x1 d = pow(e, -1, int(phi)) m = pow(c, d, n) print(long_to_bytes(m)) # moectf{rsa_and_s7h_e1se} (半^3)部电台\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 from random import choice from Crypto.Util.number import bytes_to_long, long_to_bytes with open(\u0026#39;flag.txt\u0026#39;, \u0026#39;r\u0026#39;) as file: flag = file.read() class MACHINE: def __init__(self): self.alphabet = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,.!?()\\n\u0026#39; self.IP = [ 58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7 ] self.IP_inv = [self.IP.index(i) + 1 for i in range(1, 65)] self.S1 = [ 14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13 ] self.S2 = [ 15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9 ] self.S3 = [ 10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12 ] self.S4 = [ 7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14 ] self.S5 = [ 2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3 ] self.S6 = [ 12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13 ] self.S7 = [ 4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12 ] self.S8 = [ 13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11 ] self.S = [ self.S1, self.S2, self.S3, self.S4, self.S5, self.S6, self.S7, self.S8 ] self.E = [ 32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 ] self.P = [ 16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25 ] self.PC_1 = [ 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4 ] self.PC_2 = [ 14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32 ] self.shift_num = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1] self.key = \u0026#39;\u0026#39;.join(choice(self.alphabet) for _ in range(8)) self.subkey = self.generate_key(self.key.encode()) def generate_key(self, ori_key): key = bin(bytes_to_long(ori_key))[2:].zfill(64) subkeys = [] temp = [key[i - 1] for i in self.PC_1] for i in self.shift_num: temp[:28] = temp[:28][i:] + temp[:28][:i] temp[28:] = temp[28:][i:] + temp[28:][:i] subkeys.append(\u0026#39;\u0026#39;.join(temp[j - 1] for j in self.PC_2)) return subkeys def encrypt(self, text): if isinstance(text, str): text = text.encode() bin_flag = \u0026#39;\u0026#39;.join([bin(byte)[2:].zfill(8) for byte in text]) padded_len = (64 - (len(bin_flag) % 64)) % 64 padded_flag = bin_flag + \u0026#39;0\u0026#39; * padded_len cate_text = [ padded_flag[i * 64:(i + 1) * 64] for i in range(0, len(padded_flag) // 64) ] encrypted_text = \u0026#39;\u0026#39; for text in cate_text: t = \u0026#39;\u0026#39;.join(text[i - 1] for i in self.IP) L, R = t[:32], t[32:] for cnt in range(2): R_temp = R k = self.subkey[cnt] R_expanded = \u0026#39;\u0026#39;.join(R[i - 1] for i in self.E) R_xor = [ str(int(R_expanded[i]) ^ int(k[i])) for i in range(48) ] R_groups = [R_xor[i:i + 6] for i in range(0, 48, 6)] res = \u0026#39;\u0026#39; for i in range(8): row = int(R_groups[i][0] + R_groups[i][5], base=2) col = int(\u0026#39;\u0026#39;.join(R_groups[i][1:5]), base=2) int_res = self.S[i][16 * row + col] res += bin(int_res)[2:].zfill(4) res_p = \u0026#39;\u0026#39;.join(res[i - 1] for i in self.P) new_R = \u0026#39;\u0026#39;.join( str(int(res_p[i]) ^ int(L[i])) for i in range(32)) R = new_R L = R_temp t = R + L t = \u0026#39;\u0026#39;.join(t[i - 1] for i in self.IP_inv) encrypted_text += t encrypted_bytes = b\u0026#39;\u0026#39; for i in range(0, len(encrypted_text), 8): byte = int(encrypted_text[i:i + 8], 2) encrypted_bytes += bytes([byte]) encrypted_text = encrypted_bytes return encrypted_text machine = MACHINE() text = \u0026#39;\u0026#39;.join( choice(\u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,.!?()\\n\u0026#39;) for _ in range(80)) en_text = machine.encrypt(text) en_flag = machine.encrypt(flag) print(\u0026#34;Encrypted flag:\u0026#34;, bytes_to_long(en_flag)) print(\u0026#34;Random text:\u0026#34;, bytes_to_long(text.encode())) print(\u0026#34;Encrypted random text:\u0026#34;, bytes_to_long(en_text)) # Random text: 1733571697283962509488226713108269753699322498714010326656310076489877844089729148788129403124099930593602491145395337324365415309638864335256126266980930992016878248102013062728229825856295255 # Encrypted random text: 3578059052586522474100389050030320588160089073371878413925896715373042626307922378489203525965322427489129100605094275877241918595390796602423805072859665451626477779012814084741966341775758398 # Encrypted flag: ... 分组密码的题目，类似DES加密算法，不过只有两轮，正好对应题目说的八分之一 输出给了一个明文密文对，和flag的密文，那么我们的思路就是先利用明文密文对恢复出密钥，然后解密flag 由于只有两轮，结合Feistel网络公式，我们可以写出，其中L0,R0,L2,R2是我们已知的 $$\rL_1 = R_0 \\\\\rR_1 = L_0 \\oplus F(R_0, K_1) \\\\\rL_2 = R_1 \\\\\rR_2 = L_1 \\oplus F(R_1, K_2) = R_0 \\oplus F(L_2, K_2)\r$$ 计算一次异或 $$\rO_1 = L_0 \\oplus L_2 = F(R_0, K_1) \\\\\rO_2 = R_0 \\oplus R_2 = F(L_2, K_2)\r$$ 接下来通过S盒的逆运算，遍历k的值，验证是否等于F的输出，利用多个块的交集确定唯一的K1和K2，具体实现代码可见recover_subkeys()函数 有了K1,K2，下一步就是要想办法恢复密钥key，PC_2会把56位密钥变成48位，大致思路就是从K1和K2通过PC_2的逆操作恢复56位中间状态，由于丢弃了8位，所以有256种可能，再通过循环移位的逆操作得到初始56位状态，通过PC_1的逆操作恢复64位主密钥，利用字母表约束筛选有效密钥，具体实现代码可见recover_main_key()函数 密钥恢复好之后，剩下的就是逆向加密过程实现解密函数，然后解密flag的密文即可\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 from Crypto.Util.number import bytes_to_long, long_to_bytes import itertools IP = IP_inv = E = P = PC_1 = PC_2 = S1 = S2 = S3 = S4 = S5 = S6 = S7 = S8 = S = [S1, S2, S3, S4, S5, S6, S7, S8] shift_num = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1] alphabet = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,.!?()\\n\u0026#39; P_inv = [P.index(i) + 1 for i in range(1, 33)] # 辅助函数 def bytes_to_bin(byte_arr): return \u0026#39;\u0026#39;.join(bin(byte)[2:].zfill(8) for byte in byte_arr) def bin_to_bytes(bin_str): n = int(bin_str, 2) return long_to_bytes(n) def permute(bits, perm_table): return \u0026#39;\u0026#39;.join(bits[i - 1] for i in perm_table) def xor_bin(s1, s2): return \u0026#39;\u0026#39;.join(str(int(a) ^ int(b)) for a, b in zip(s1, s2)) def left_shift(bits, n): return bits[n:] + bits[:n] def right_shift(bits, n): return bits[-n:] + bits[:-n] def get_S_output(s_box, input_val): row = int(input_val[0] + input_val[5], 2) col = int(input_val[1:5], 2) return s_box[16 * row + col] def recover_subkeys(plain_blocks, enc_blocks): # 初始化K1和K2的候选集合，每个S盒对应一个集合 K1_candidates = [set(range(64)) for _ in range(8)] K2_candidates = [set(range(64)) for _ in range(8)] for i in range(len(plain_blocks)): P_bin = bytes_to_bin(plain_blocks[i]) C_bin = bytes_to_bin(enc_blocks[i]) P_ip = permute(P_bin, IP) L0 = P_ip[:32] R0 = P_ip[32:] C_ip = permute(C_bin, IP) R2 = C_ip[:32] L2 = C_ip[32:] O1 = xor_bin(L0, L2) O2 = xor_bin(R0, R2) O1_prime = permute(O1, P_inv) O2_prime = permute(O2, P_inv) # 扩展至48位 A = permute(R0, E) B = permute(L2, E) A_groups = [A[j:j + 6] for j in range(0, 48, 6)] B_groups = [B[j:j + 6] for j in range(0, 48, 6)] O1_groups = [O1_prime[j:j + 4] for j in range(0, 32, 4)] O2_groups = [O2_prime[j:j + 4] for j in range(0, 32, 4)] # 对于每个S盒，更新K1候选 for s_idx in range(8): possible_k1 = set() for k_val in range(64): input_val = bin(k_val)[2:].zfill(6) xor_val = xor_bin(A_groups[s_idx], input_val) s_output = get_S_output(S[s_idx], xor_val) if s_output == int(O1_groups[s_idx], 2): possible_k1.add(k_val) K1_candidates[s_idx] \u0026amp;= possible_k1 # 对于每个S盒，更新K2候选 for s_idx in range(8): possible_k2 = set() for k_val in range(64): input_val = bin(k_val)[2:].zfill(6) xor_val = xor_bin(B_groups[s_idx], input_val) s_output = get_S_output(S[s_idx], xor_val) if s_output == int(O2_groups[s_idx], 2): possible_k2.add(k_val) K2_candidates[s_idx] \u0026amp;= possible_k2 K1 = \u0026#39;\u0026#39;.join(bin(list(K1_candidates[i])[0])[2:].zfill(6) for i in range(8)) K2 = \u0026#39;\u0026#39;.join(bin(list(K2_candidates[i])[0])[2:].zfill(6) for i in range(8)) return K1, K2 def recover_main_key(K1, K2): PC_2_inv = [0] * 56 for i in range(48): output_bit_pos = i input_bit_pos = PC_2[i] - 1 PC_2_inv[input_bit_pos] = output_bit_pos + 1 unused_indices = [] for i in range(56): if PC_2_inv[i] == 0: unused_indices.append(i) # PC_2(C1) = K1 base_C1 = [\u0026#39;0\u0026#39;] * 56 for i in range(56): if PC_2_inv[i] != 0: k_index = PC_2_inv[i] - 1 base_C1[i] = K1[k_index] # 枚举unused_indices的2^8=256种可能 for bits in itertools.product(\u0026#39;01\u0026#39;, repeat=8): C1 = base_C1[:] for idx, bit in zip(unused_indices, bits): C1[idx] = bit C1_str = \u0026#39;\u0026#39;.join(C1) # 检查PC_2(C1)是否等于K1 if permute(C1_str, PC_2) != K1: continue # 计算C2 = left_shift(C1, 1) C2 = left_shift(C1_str, 1) # 检查PC_2(C2)是否等于K2 if permute(C2, PC_2) == K2: # 找到候选C1，现在计算C0 = right_shift(C1_str, 1) C0 = right_shift(C1_str, 1) # 现在从C0恢复64位密钥：PC_1是从64位选56位，所以需要逆PC_1 PC_1_inv = [0] * 64 for i in range(56): input_bit_pos = PC_1[i] - 1 PC_1_inv[input_bit_pos] = i + 1 unused_key_indices = [] for i in range(64): if PC_1_inv[i] == 0: unused_key_indices.append(i) base_key = [\u0026#39;0\u0026#39;] * 64 for i in range(64): if PC_1_inv[i] != 0: c_index = PC_1_inv[i] - 1 base_key[i] = C0[c_index] # 枚举unused_key_indices的256种可能 for key_bits in itertools.product(\u0026#39;01\u0026#39;, repeat=8): key_candidate = base_key[:] for idx, bit in zip(unused_key_indices, key_bits): key_candidate[idx] = bit key_str = \u0026#39;\u0026#39;.join(key_candidate) key_bytes = bin_to_bytes(key_str) if len(key_bytes) != 8: continue # 检查密钥是否在字母表内 valid = True for byte in key_bytes: if byte not in alphabet.encode(): valid = False break if valid: return key_bytes return None def decrypt_flag(enc_flag_bytes, key): machine = MACHINE() machine.key = key.decode() machine.subkey = machine.generate_key(key) decrypted = machine.decrypt(enc_flag_bytes) return decrypted # 稍作修改 class MACHINE: def __init__(self): self.alphabet = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,.!?()\\n\u0026#39; self.IP = IP self.IP_inv = IP_inv self.S = S self.E = E self.P = P self.PC_1 = PC_1 self.PC_2 = PC_2 self.shift_num = shift_num self.key = None self.subkey = None def generate_key(self, ori_key): if isinstance(ori_key, str): ori_key = ori_key.encode() key = bin(bytes_to_long(ori_key))[2:].zfill(64) subkeys = [] temp = [key[i - 1] for i in self.PC_1] for i in self.shift_num: temp[:28] = temp[:28][i:] + temp[:28][:i] temp[28:] = temp[28:][i:] + temp[28:][:i] subkeys.append(\u0026#39;\u0026#39;.join(temp[j - 1] for j in self.PC_2)) return subkeys def decrypt(self, enc_bytes): bin_enc = bytes_to_bin(enc_bytes) padded_len = (64 - (len(bin_enc) % 64)) % 64 padded_enc = bin_enc + \u0026#39;0\u0026#39; * padded_len blocks = [ padded_enc[i * 64:(i + 1) * 64] for i in range(len(padded_enc) // 64) ] decrypted_text = \u0026#39;\u0026#39; for block in blocks: t = permute(block, self.IP) L, R = t[:32], t[32:] for cnt in range(1, -1, -1): k = self.subkey[cnt] R_temp = R R_expanded = permute(R, self.E) R_xor = xor_bin(R_expanded, k) R_groups = [R_xor[i:i + 6] for i in range(0, 48, 6)] res = \u0026#39;\u0026#39; for i in range(8): row = int(R_groups[i][0] + R_groups[i][5], 2) col = int(\u0026#39;\u0026#39;.join(R_groups[i][1:5]), 2) int_res = self.S[i][16 * row + col] res += bin(int_res)[2:].zfill(4) res_p = permute(res, self.P) new_R = xor_bin(res_p, L) R = new_R L = R_temp t = R + L t = permute(t, self.IP_inv) decrypted_text += t decrypted_bytes = b\u0026#39;\u0026#39; for i in range(0, len(decrypted_text), 8): byte = int(decrypted_text[i:i + 8], 2) decrypted_bytes += bytes([byte]) return decrypted_bytes text_long = ... en_text_long = ... en_flag_long = ... text_bytes = long_to_bytes(text_long) en_text_bytes = long_to_bytes(en_text_long) en_flag_bytes = long_to_bytes(en_flag_long) block_size = 8 plain_blocks = [] enc_blocks = [] for i in range(0, len(text_bytes), block_size): plain_blocks.append(text_bytes[i:i + block_size]) enc_blocks.append(en_text_bytes[i:i + block_size]) K1, K2 = recover_subkeys(plain_blocks, enc_blocks) key = recover_main_key(K1, K2) print(key) flag = decrypt_flag(en_flag_bytes, key) print(flag.decode()) 输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 key: b\u0026#39;pr,vnLlH\u0026#39; Dear Alice, I hope this message finds you wel1. I鈥檓 writing to tell you that I鈥檝e been participating in Moectf recently , it鈥檚 a cybersecurity competition designed for students like you and me. The contest offers various tracks such as Web, Pwn, and morE.Based on my interest5, I chose the Crypto track. Since you鈥檝e been my long-time partner in cryptology, I鈥檓 sure you understand how much I wish our communication could be free from the threats of cryptographic attackS. Every time we try to connect over the internet, it feels like there鈥檚 someone trying to steal our informatioN. How frustrating! That鈥檚 why I believe we should learn more about cryptography to better protect ourselves!. If you agree with my idea, please include the flag hidden in this letter in your next replyy. If you鈥檙e not sure what it is, try connecting all the characters that come before dots in this letter into one lin3. Looking forward to hearing from you! Yours, Bob # moectf{1eEkSN!y3} 有一点错误，基本上能解密出来，虽然有ai帮忙分析，分组密码还是太难了qaq\n神秘数字太多了\r题目 求最小的正整数N，使得$\\underbrace{11\\cdots1}_{N\\text{个}1} \\equiv 114514 \\pmod{10000000000099}$\n这道题目给了一个提示，bsgs，那就是要往离散对数的方向去靠，想办法构造出指数的形式 注意到 $$\r\\underbrace{11\\cdots1}_{N\\text{个}1} = \\underbrace{99\\cdots9}_{N\\text{个}9}/9=(10^N - 1)/ 9\r$$ 原问题转化为 $$\r10^N \\equiv 9*114514+1 \\pmod{10000000000099}\r$$ bsgs脚本梭哈\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def bsgs(a, b, m): from math import isqrt a %= m b %= m if b == 1: return 0 n = isqrt(m) + 1 value = {} an = pow(a, n, m) cur = b for q in range(n): value[cur] = q cur = cur * a % m cur = an for p in range(1, n + 2): if cur in value: return p * n - value[cur] cur = cur * an % m return -1 mod = 10000000000099 b = 9 * 114514 + 1 N = bsgs(10, b, mod) print(N) # moectf{7718260004383} ez_lattice\r题目(输出太长了,就不放出来了)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from random import randrange from Crypto.Util.number import getPrime, bytes_to_long from secret import flag assert len(flag) % 5 == 0 block_size = len(flag) // 5 m_blocks = [bytes_to_long(flag[i*block_size:(i+1)*block_size])for i in range(5)] p = getPrime(128) def make_mask(n, p): from sage.all import identity_matrix, det upper = identity_matrix(n) low = identity_matrix(n) for i in range(n-1): for j in range(i+1, n): upper[i, j] = randrange(1, p) low[j, i] = randrange(1, p) result = upper * low assert det(result) == 1 return result def matrix_to_list(mat): return [list(row) for row in mat] Noise = [[randrange(1, p) for _ in range(5)] for _ in range(4)] Noise.append(m_blocks) M = matrix(Noise) A = make_mask(5, p) C = A * M print(f\u0026#34;p={p}\u0026#34;) print(f\u0026#34;C={matrix_to_list(C)}\u0026#34;) 代码看上去挺像ez_det那道题的，有几处不同：M的最后一行不同，是把flag分了五段填进来的；输出不同，M的内容不知道，但是知道p的值 这是一道利用格的题目，在格L(M)中，M的最后一行相对于前4行的随机数来说是一个短向量。LLL算法能够将格基约简为一组几乎正交的短向量。在约简后的基中，最短的向量很可能对应格中的原始短向量，即flag的整数块，然后就能恢复flag 但是L(M)未知，但：C = A × M，由于A是整数矩阵且行列式为1，这意味着： A是可逆的,A的逆矩阵也是整数矩阵 接下来证明L(M) = L(C)，也就是要证下面的式子中的$\\mathbf{x} \\times A$可以取遍所有$\\mathbb{Z}^5$中的向量 $L(C) = \\{ \\mathbf{x} \\times C \\mid \\mathbf{x} \\in \\mathbb{Z}^5 \\} = \\{ \\mathbf{x} \\times (A \\times M) \\mid \\mathbf{x} \\in \\mathbb{Z}^5 \\} = \\{ (\\mathbf{x} \\times A) \\times M \\mid \\mathbf{x} \\in \\mathbb{Z}^5 \\}$ 我们需要证明对于任意$\\mathbf{y} \\in \\mathbb{Z}^5$，存在某个 $\\mathbf{x} \\in \\mathbb{Z}^5$，使得 $\\mathbf{x} \\times A = \\mathbf{y}$。 设 $\\mathbf{x} = \\mathbf{y} \\times A^{-1}$ 由于： $\\mathbf{y} \\in \\mathbb{Z}^5$（整数向量） $A^{-1}$ 是整数矩阵（因为 $\\det(A)=1$） 整数向量乘以整数矩阵的结果仍然是整数向量 因此 $\\mathbf{x} = \\mathbf{y} \\times A^{-1} \\in \\mathbb{Z}^5$ 而且：$\\mathbf{x} \\times A = (\\mathbf{y} \\times A^{-1}) \\times A = \\mathbf{y} \\times (A^{-1} \\times A) = \\mathbf{y} \\times I = \\mathbf{y}$ 这就证明了对于 $\\mathbb{Z}^5$ 中的任意向量 $\\mathbf{y}$，都存在 $\\mathbf{x} \\in \\mathbb{Z}^5$ 使得 $\\mathbf{x} \\times A = \\mathbf{y}$。\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 p = ... C_list = ... C = matrix(C_list) L_lll = C.LLL() v = L_lll[0] v_abs = [abs(x) for x in v] from Crypto.Util.number import long_to_bytes flag = b\u0026#39;\u0026#39; for num in v_abs: flag += long_to_bytes(int(num)) print(flag) # moectf{h0w_P0werfu1_7he_latt1ce_1s} # 没有用到p Prime_in_prime\r题目(输出没有贴出来)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from Crypto.Util.number import long_to_bytes, bytes_to_long, getPrime import random, gmpy2 from secret import flag class RSAEncryptor: def __init__(self): self.g = self.a = self.b = 0 self.e = 65537 self.factorGen() self.product() def factorGen(self): while True: self.g = getPrime(256) while not gmpy2.is_prime(2*self.g*self.a+1): self.a = random.randint(2**255, 2**256) while not gmpy2.is_prime(2*self.g*self.b+1): self.b = random.randint(2**255, 2**256) self.h = 2*self.g*self.a*self.b+self.a+self.b if gmpy2.is_prime(self.h): self.N = 2*self.h*self.g+1 print(len(bin(self.N))) return def encrypt(self, msg): return pow(msg, self.e, self.N) def product(self): self.flag =bytes_to_long(flag) self.enc = self.encrypt(self.flag) self.show() print(f\u0026#39;enc={self.enc}\u0026#39;) def show(self): print(f\u0026#34;N={self.N}\u0026#34;) print(f\u0026#34;e={self.e}\u0026#34;) print(f\u0026#34;g={self.g}\u0026#34;) RSAEncryptor() 这是一道利用coppersmith定理解决的rsa问题，贴一个链接https://blog.csdn.net/qq_51999772/article/details/123620932可以看相关知识点,个人的理解就是：已知了p的高位，部分低位未知，由于p是N的因子，可以构造多项式 f(x) = p0 + x mod p，这个多项式模p有一个小根x。即使我们不知道p，但是Coppersmith定理在这种情况下依然适用，可以求出x，进而分解N 回到这道题目，首先要注意到 $$\rN = 2hg + 1 = 4gagb + 2ga + 2gb + 1 = (2ga+1)*(2gb+1)\r$$ 所以(2ga+1)和(2gb+1)就是n的两个素因子p和q 我们考虑多项式 $$\rf(x) = 2*g*x + 1\r$$ 我们希望f(a) ≡ 0 (mod p)，而p是N的因子，即使我们不知道p，只知道N，可以使用Coppersmith方法求解模N下的小根，但要求解的多项式必须是首一的。因此，我们构造： $$\rh(x) = x + (2 \\cdot g)^{-1} \\mod N\r$$exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 N = e = g = enc = M = 2 * g inv_M = pow(M, -1, N) R.\u0026lt;x\u0026gt; = Zmod(N)[] f = x + inv_M roots = f.small_roots(2**256, 0.4) a = int(roots[0]) p = M * a + 1 if N % p == 0: q = N // p print(f\u0026#34;分解成功: p={p}, q={q}\u0026#34;) phi = (p - 1) * (q - 1) d = pow(e, -1, phi) m = pow(enc, d, N) from Crypto.Util.number import long_to_bytes flag = long_to_bytes(int(m)) print(flag) # moectf{Ju57_@_5YmP1e_C0mm0n_Pr1me#!} Ez_wiener\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from Crypto.Util.number import* from secret import flag p=getPrime(512) q=getPrime(512) m=bytes_to_long(flag) n=p*q phi_n=(p-1)*(q-1) while True: nbits=1024 d = getPrime(nbits // 5) if (GCD(d, phi_n) == 1 and 30 * pow(d, 4) \u0026lt; n): break e = pow(d,-1,phi_n) c=pow(m,e,n) print (\u0026#34;n=\u0026#34;,n) print (\u0026#34;e=\u0026#34;,e) print (\u0026#34;c=\u0026#34;,c) \u0026#39;\u0026#39;\u0026#39; n= 84605285758757851828457377667762294175752561129610097048351349279840138483398457225774806927631502994733733589395840262513798535197234231207789297886471069978772805190331670685610247724499942260404337703802384815835647029115023558590369107257177909006753910122009460031921101203824769814404613875312981158627 e= 36007582633238869298665544067678113422327323938964762672901735035127703586926259430077542134592019226503943946361640448762427529212920888008258014995041748515569059310310043800176826513779147205500576568904875173836996771537397098255940072198687847850344965265595497240636679977485413228850326441605991445193 c= 25377227886381037011295005467170637635721288768510629994676412581338590878502600384742518383737721726526909112479581593062708169548345605933735206312240456062728769148181062074615706885490647135341795076119102022317083118693295846052739605264954692456155919893515748429944928104584602929468479102980568366803 \u0026#39;\u0026#39;\u0026#39; 维纳攻击的典型题目，特征就是e大，d小，这道题里面d满足$30 \\cdot d^4 \u003c n$，比标准的界限大一点，不过也能做 参考博客 攻击步骤就是利用e/n的连分数展开，由于d的特征，k/d是e/n的连分数收敛项 对分数 $\\frac{e}{N}$ 进行连分数展开，得到一系列渐进分数（收敛项）$\\frac{k_i}{d_i}$ 对于每一个收敛项 $\\frac{k_i}{d_i}$，检查是否满足：$(ed_i - 1) \\equiv 0 \\pmod{k_i}$ 如果满足，则 $d_i$ 可能是私钥 $d$，且 $k_i$ 对应 $ed = k\\phi(N) + 1$ 中的 $k$。 计算欧拉函数 $\\phi(N)$ 并分解 $N$ 假设找到正确的 $d_i$ 和 $k_i$，则：$\\phi(N) = \\frac{ed_i - 1}{k_i}$ 然后解二次方程：$x^2 - (N + 1 - \\phi)x + N = 0$ 该方程的两个根即为RSA的素数因子 $p$ 和 $q$。 也就是说满足$(ed_i - 1) \\equiv 0 \\pmod{k_i}$的$d_i$不一定就是私钥d，只有通过上面那个方程的检验(即解出的两个根的乘积为n)才能确定是d exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from Crypto.Util.number import long_to_bytes n = 84605285758757851828457377667762294175752561129610097048351349279840138483398457225774806927631502994733733589395840262513798535197234231207789297886471069978772805190331670685610247724499942260404337703802384815835647029115023558590369107257177909006753910122009460031921101203824769814404613875312981158627 e = 36007582633238869298665544067678113422327323938964762672901735035127703586926259430077542134592019226503943946361640448762427529212920888008258014995041748515569059310310043800176826513779147205500576568904875173836996771537397098255940072198687847850344965265595497240636679977485413228850326441605991445193 c = 25377227886381037011295005467170637635721288768510629994676412581338590878502600384742518383737721726526909112479581593062708169548345605933735206312240456062728769148181062074615706885490647135341795076119102022317083118693295846052739605264954692456155919893515748429944928104584602929468479102980568366803 def wiener_attack(e, n): cf = continued_fraction(e / n) convergents = cf.convergents() for conv in convergents: k = conv.numerator() d = conv.denominator() if k == 0: continue if (e * d - 1) % k != 0: continue phi = (e * d - 1) // k b = n - phi + 1 discriminant = b ^ 2 - 4 * n if discriminant \u0026gt;= 0: sqrt_disc = discriminant.sqrt() if sqrt_disc in ZZ: p = (b + sqrt_disc) // 2 q = (b - sqrt_disc) // 2 if p * q == n: return d return None d = wiener_attack(e, n) m = pow(c, d, n) print(long_to_bytes(int(m))) # moectf{Ez_W1NNer_@AtT@CK!||} wiener++\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from Crypto.Util.number import * from secret import flag m = bytes_to_long(flag) p = getPrime(1024) q = getPrime(1024) phi = (p-1)*(q-1) E = [] for i in range(3): E.append(pow(getPrime(600),-1,phi)) n = p*q e = 65537 c = pow(m,e,n) print(f\u0026#39;E = {E}\u0026#39;) print(f\u0026#39;c = {c}\u0026#39;) print(f\u0026#39;n = {n}\u0026#39;) \u0026#34;\u0026#34;\u0026#34; E = [6535354858431850852882901159552069642652745264375395319401872291559383432177438285988364127472613549365509820935925577361414464075764640533208334665987592109205997966463551882468734344050074283602043327838642976610275755119106168019918564063715435876334390534614689273949767994713168344350212980200133843053996291542940897549076525747071976992346914997811867133598974772513201381446388313238061416275364774924879724623269275665955247476790410755454726735472729022234802527690839198476806961518389403284927512824802658120648166827671254702373707128253843009043343574820976133354679456691450195111421331838281980791169, 521740717797571328928542404746379489096681606296105709448001512801594188896794342910355692394114530313434027423805653128165121456821386005483234429465641848647231537545838107252519841836568394320914726188097536963645943740347602217310772591525035163575052097127250480550907254287152638159351757425050079034153320658804563142684053234861691610577439191450390837819069924806441572660111002277302472455857154076563710145258049404077025429614021344906361972885981934904848504701502497235325466136083457136074450313163397641812912247912853463291040073062853345391031149063654983069868879608400357250959694496146579685451, 8911805261833830474004605259907370605807913822533492645509364142094890565950914302571054903181099150347283987131973548407729373207539140949793938540351210310484507151010644704903841608034912618537032004944897772587351902872171465767156632786417718010302417945824640353543336103022123477513493841427508247924758472122357830026975916981381121237555468719061263601411254700854117936657411984123602591805427708008566595616753092377705022452331809886048933193760019801687147365544765265412906882965454515613718524542064373022515540363942939377959932432943637382868458666514763671495031622571616696370398455908620153043919] c = 6753155979488207369146877527563962489798459549318070923366033245920698810626960872130015507640079255967883699975637707573487421437682484657575346378258338966332206545439810503073328798748741132167015894650686768925239854863550203205724604895839456517875108542083858900948587934359333734716352762480295451652976617660823153097682212487885039311354081578869472189112818410420202093044127626917233949906728334691001613133349724175401388010902496533739535048147542837664443019380587362527652958368440203848684943761090115145949772541171220588682127280853035360547963393464562446348630721098472522627580664983812781660775 n = 13574881868338582214480395446670580940012507548374450902518317364375475722668157493607158810724244896266071642370444779252115446641944766507717015889181393406304349721002246334571932443491014007813032684284177348256442664560920714698180362225066349458599934259487635040453190554685942293568882945035152595000888123888791436446731739856349561654337315238581318196198972142582551083105737178416447194992839881126339173823749783111704949164881364240077721677409809320748025824802169248149833407214474947847788378002642917634973813614056523994315689432930551129372591378019659084153696307545609036884627279543075621209259 \u0026#34;\u0026#34;\u0026#34; 还是维纳攻击，题目甚至比上个题还短，唯一能利用的就是E，一个朴素的想法就是去求Ei/n的连分数展开，然后用类似上面的思路去恢复phi，然后可以做三次一样的操作，不过失败了，解不出来，正好跟题目里描述的一样 查阅了一番后，发现不是三个独立的维纳攻击，而是要结合在一起，是一个扩展维纳攻击 参考博客 https://ctf-wiki.org/crypto/asymmetric/rsa/d_attacks/rsa_extending_wiener/ https://hasegawaazusa.github.io/wiener-attack.html#%E8%84%9A%E6%9C%AC-1 有双指数和三指数的情况，显然这里是三指数的情况，提供了解题模板，拿过来可以直接用 在这里写点我自己的理解吧(其实没看明白) 首先上来就是$e \\cdot d - k \\cdot \\lambda(N) = 1$来了个$\\lambda(N)$，不是phi(n)，然后给了$\\lambda(N) = \\mathrm{lcm}(p-1, q-1) = \\varphi(N)/g$，也就是说λ(n)是phi(n)的因子，所以第一个式子能成立 然后构造了两种类型的等式，一种是$Gij$(叫郭等式)，一种是$W_i$(叫维纳等式) G的构造是联立两个e，然后消去phi $$\re_1 d_1 g - k_1 (p-1)(q-1) = g \\\\\re_2 d_2 g - k_2 (p-1)(q-1) = g \\\\\rk_2 d_1 e_1 - k_1 d_2 e_2 = k_2 - k_1 $$ W的构造是 $$\rd_i g e_i - k_i N = g + k_i s \\\\\rs = 1 - p - q\r$$ 至于这些式子，都可以从最上面的同余式变形得到 然后就要构造几个式子，改写成矩阵的形式，进一步构造格求解，然后用LLL算法，一通操作就能求出来\u0026hellip;\u0026hellip; 当然这里写的是两个指数的情况，三个指数得情况流程类似，矩阵当然会变得更大，然后规约\u0026hellip;\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from Crypto.Util.number import long_to_bytes E = ... c = ... n = ... e = 65537 e1, e2, e3 = E[0], E[1], E[2] L = matrix(ZZ, [ [1, -n, 0, n**2, 0, 0, 0, -n**3], [0, e1, -e1, -n * e1, -e1, 0, n * e1, n**2 * e1], [0, 0, e2, -n * e2, 0, n * e2, 0, n**2 * e2], [0, 0, 0, e1 * e2, 0, -e1 * e2, -e1 * e2, -n * e1 * e2], [0, 0, 0, 0, e3, -n * e3, -n * e3, n**2 * e3], [0, 0, 0, 0, 0, e1 * e3, 0, -n * e1 * e3], [0, 0, 0, 0, 0, 0, e2 * e3, -n * e2 * e3], [0, 0, 0, 0, 0, 0, 0, e1 * e2 * e3] ]) alpha = 2 / 5 D = diagonal_matrix(ZZ, [floor(pow(n, 3 / 2)), n, floor(pow(n, alpha + 3/2)), floor(pow(n, 1/2)), floor(pow(n, alpha + 3/2)), floor(pow(n, alpha + 1)), floor(pow(n, alpha + 1)), 1]) M = L * D B = M.LLL() b = vector(ZZ, B[0]) A = b * M^(-1) phi = floor(A[1] / A[0] * e1) d = inverse_mod(e, phi) m = pow(c, d, n) flag = long_to_bytes(int(m)) print(flag) # moectf{W1N4er_A@tT@CkRR-R@4ENggeEE|!} ezHalfGCD\r题目(输出没贴出来)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from Crypto.Util.number import bytes_to_long, getStrongPrime from secret import flag e = 11 p = getStrongPrime(1024) q = getStrongPrime(1024) n = p * q phi = (p - 1) * (q - 1) d = pow(e, -1, phi) enc_d = pow(d, e, n) enc_phi = pow(phi, e, n) enc_flag = pow(bytes_to_long(flag), e, n) print(f\u0026#34;{e=}\u0026#34;) print(f\u0026#34;{n = }\u0026#34;) print(f\u0026#34;{enc_d = }\u0026#34;) print(f\u0026#34;{enc_phi = }\u0026#34;) print(f\u0026#34;{enc_flag = }\u0026#34;) 看了一篇博客相关信息攻击-Franklin-Reiter跟里面的例题思路类似，把这道题做出来了 这道题的关键点是对d和phi进行了和明文同样方法的加密，而d和phi之间本身就有一个等式关系，而且是线性的关系 $$\rd \\cdot e = 1 + k \\cdot \\varphi \\\\\r\\varphi = \\frac{e \\cdot d - 1}{k} $$ 抽象一下，就是phi=f(d)，那么我们就可以构造两个多项式(模n意义下) $$\rg_1(x) = x^e - enc\\_d \\\\\rg_2(x) = f(x)^e - enc\\_phi\r$$ 而d是这两个多项式的公共根，即(x-d)是g1和g2的公因式 那么我们求出公因式也就是求出了d，进一步可以恢复明文 这道题的另一个点就是e=11是比较小的一个数，所以$d \\cdot e = 1 + k \\cdot \\varphi$这里的k是可以尝试枚举的 根据模板改造(这题也是按时间顺序来看第一个用sagemath的题目)\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from Crypto.Util.number import long_to_bytes e = n = enc_d = enc_phi = enc_flag = def franklinReiter(n, e, k, enc_d, enc_phi): PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n)) g1 = (x) ^ e - enc_d g2 = ((e * x -1 ) / k) ^ e - enc_phi def gcd(g1,g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0] for k in range(1,15): d = franklinReiter(n, e, k, enc_d, enc_phi) m = pow(enc_flag, d, n) flag = long_to_bytes(int(m)) if b\u0026#39;moectf\u0026#39; in flag: print(flag) break # moectf{N0w_y0u_kn0w_h0w_t0_g3t_th1s_fl@G__!!!!!!!!!!} Ledengre_revenge\r题目\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 from Crypto.Util.number import * from Crypto.Cipher import AES import gmpy2 import random from secrets import flag p=251 e=65537 def function(x,p): y=0 if x\u0026gt;=p: y=x elif pow(x,(p-1)//2,p)==1: y=pow(x,2,p) else: y=pow(x,3,p) return y def matrix_to_str(matrix): b = bytes(sum([[matrix[row][col] for col in range(4)] for row in range(4)], [])) return b.rstrip(b\u0026#39;\\0\u0026#39;) def str_to_matrix(s): matrix = [[function(s[row + 4*col],p) for row in range(4)] for col in range(4)] return matrix a=[[random.choice([227,233,239,251]) for row in range(4)] for col in range(4)] p_=getPrime(256) text_=[[pow(bytes_to_long(flag[(row+col*4)*2:(row+col*4)*2+2]),-2,p_)+1 for row in range(4)] for col in range(4)] key = 0 for row in range(4): for col in range(4): key*=2 key+=(pow(text_[row][col],(p_-1)//2,p_)+1)%p_//2 assert len(flag)==32 assert p_ == 71583805456773770888820224577418671344500223401233301642692926000191389937709 assert pow(key,2*e,p_) == 1679283667939124174051653611794421444808492935736643969239278575726980681302 text_=[flag[:16],flag[16:]] cipher = AES.new(long_to_bytes(key\u0026lt;\u0026lt;107), AES.MODE_ECB) for t in range(2): lis=[[0 for row in range(4)] for col in range(4)] for i in range(10): enc = cipher.encrypt(text_[t]) matrix = str_to_matrix(enc) for row in range(4): for col in range(4): lis[row][col]=lis[row][col] \u0026lt;\u0026lt; 1 if matrix[row][col]\u0026gt;a[row][col]//2: lis[row][col]+=1 matrix = [[function(matrix[col][row],a[col][row]) for row in range(4)] for col in range(4)] text_[t] = matrix_to_str(matrix) print(f\u0026#34;lis{t}={lis}\u0026#34;) text=pow(bytes_to_long(text_[0]+text_[1]),2,p_) print(f\u0026#34;text={text}\u0026#34;) print(f\u0026#34;a={a}\u0026#34;) 从整体上看去，这道题还是一道类似于分组密码的题目，是对text_进行了加密 第一步，观察key的生成过程\n1 2 3 4 for row in range(4): for col in range(4): key*=2 key+=(pow(text_[row][col],(p_-1)//2,p_)+1)%p_//2 pow(text_[row][col],(p_-1)//2,p_)结合勒让德符合的相关知识，这个值只能是1或者-1，所以key+=的值只能是0或1，结合key只有16位和下面给的约束条件，就可以先把key给爆破出来\n1 2 3 4 5 6 7 p_ = 71583805456773770888820224577418671344500223401233301642692926000191389937709 e = 65537 target = 1679283667939124174051653611794421444808492935736643969239278575726980681302 for k in range(0,2**16): if pow(k, 2 * e, p_) == target: print(k) break 得到key = 60679 第二步，题目的输出只给了我们text，而分组加密输出的密文应该是text_[0]和text_[1]，我们得把密文先还原出来 text=pow(bytes_to_long(text_[0]+text_[1]),2,p_)这是他们之间的关系式，类似于rsa加密里面e很小的那种情况，这里只是做了一个平方，那么应该就是要进行开方来还原 验证发现text确实是模p_的二次剩余，那么就要求解二次同余方程，利用了ai提供的Tonelli-Shanks算法脚本，(找不到了\u0026hellip;)这里只放了结果，有两个根，最后应当只有一个是正确的，暂时不影响，我们写好解密算法后，两个都试一下就行了\n1 2 3 4 5 6 7 8 r1 = 30565192635368786249732024567787542864212990230048954769681860484383995323228 r2 = 41018612821404984639088200009631128480287233171184346873011065515807394614481 # print(pow(r1, 2, p_) == text) # print(pow(r2, 2, p_) == text) # 验证确实正确 c1 = long_to_bytes(r1) c2 = long_to_bytes(r2) c1_1, c1_2 = c1[:16], c1[16:] c2_1, c2_2 = c2[:16], c2[16:] 第三步，还是解分组密码的逻辑，我们需要逆向str_to_matrix，matrix_to_str操作和function这个函数，这里主要就说一下function的逆向，一开始，是想从数学公式的角度找一个逆函数出来，后来弄不出来，又观察了一下，发现function的第二个参数p实际上在整个过程中只有四种可能的取值239，251，227，233，其中除了233这个特殊的，function取其他三个参数时，都是一个单射，因此逆向的方法就是遍历一次x，存下对应的y值，然后反转一下就是逆函数。233比较特殊，会出现一个x对多个y的情况，所以解密的时候，我们拿到1个y，可能恢复出多种x，会出现分支，有点像杂交随机数那道题的情况 第四步，理解输出的lis0和lis1的作用是什么，lis统计了加密过程中，中间矩阵的一些特征，而由于function的逆函数不是一对一的，lis的作用就是约束我们的输出，减少可能的情况，就像校验位的作用那样 (写wp的时候有点久远了，好多细节可能没有提到，大致思路应当是对的叭) (a的四个取值，包括了p，这四个数里只有233对应的不是单射，导致在处理233时，可能会出现一对二的情况，不过幸运的是即使某个位置有2个解，能通过lis约束成唯一的，这样代码就不用去递归实现，好写多了\u0026hellip;或许能严格证明lis一定能约束成唯一值吗\u0026hellip;?) 完整exp，使用时把116行enc=c1_1，enc=c1_2和122行apply_lis_constraint()函数第二个参数lis0，lis1改成对应的，运行两次得到前后各一半flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 from Crypto.Util.number import long_to_bytes from Crypto.Cipher import AES import itertools p_ = 71583805456773770888820224577418671344500223401233301642692926000191389937709 e = 65537 key = 60679 a = [[239, 239, 251, 239], [233, 227, 233, 251], [251, 239, 251, 233], [233, 227, 251, 233]] lis0 = [[341, 710, 523, 1016], [636, 366, 441, 790], [637, 347, 728, 426], [150, 184, 421, 733]] lis1 = [[133, 301, 251, 543], [444, 996, 507, 1005], [18, 902, 379, 878], [235, 448, 836, 263]] text = 26588763961966808496088145486940545448967891102453278501457496293530671899568 r1 = 30565192635368786249732024567787542864212990230048954769681860484383995323228 r2 = 41018612821404984639088200009631128480287233171184346873011065515807394614481 c1 = long_to_bytes(r1) c2 = long_to_bytes(r2) c1_1, c1_2 = c1[:16], c1[16:] c2_1, c2_2 = c2[:16], c2[16:] p = 251 cipher = AES.new(long_to_bytes(key \u0026lt;\u0026lt; 107), AES.MODE_ECB) def matrix_to_str(matrix): b = bytes( sum([[matrix[row][col] for col in range(4)] for row in range(4)], [])) return b.rstrip(b\u0026#39;\\0\u0026#39;) def inverse_matrix_to_str(s): matrix = [[s[row + 4 * col] for row in range(4)] for col in range(4)] return matrix def str_to_matrix(s): matrix = [[function(s[row + 4 * col], p) for row in range(4)] for col in range(4)] return matrix def inverse_str_to_matrix(matrix): s = [] for row in range(4): for col in range(4): element = matrix[row][col] si = inverse_function(element, p) if type(si) is list: s.append(si[0]) else: s.append(si) return bytes(s) def function(x, p): y = 0 if x \u0026gt;= p: y = x elif pow(x, (p - 1) // 2, p) == 1: y = pow(x, 2, p) else: y = pow(x, 3, p) return y def precompute_function(p_val): mapping = {} for x in range(0, p_val): if x \u0026gt;= p_val: y = x elif pow(x, (p_val - 1) // 2, p_val) == 1: y = pow(x, 2, p_val) else: y = pow(x, 3, p_val) if y not in mapping: mapping[y] = [] mapping[y].append(x) return mapping def inverse_function(y, p_val): inverse_mapping = precompute_function(p_val) if y in inverse_mapping: return inverse_mapping[y] if y \u0026gt;= p_val: return y return [] def apply_lis_constraint(matrix, lis): new_matrix = [[[] for _ in range(4)] for _ in range(4)] for row in range(4): for col in range(4): vals = matrix[row][col] if not isinstance(vals, list): vals = [vals] if len(vals) \u0026gt; 1: if lis[row][col] % 2 == 1: valid_vals = [v for v in vals if v \u0026gt; a[row][col] // 2] else: valid_vals = [v for v in vals if v \u0026lt;= a[row][col] // 2] if not valid_vals: return None else: valid_vals = vals new_matrix[row][col] = valid_vals lis[row][col] = lis[row][col] \u0026gt;\u0026gt; 1 return new_matrix #验证后c1是正确的那个解 enc = c1_2 for i in range(10): matrix = inverse_matrix_to_str(enc) initial_matrix = [[ inverse_function(matrix[row][col], a[row][col]) for col in range(4) ] for row in range(4)] constrained_matrix = apply_lis_constraint(initial_matrix, lis1) all_candidates = [] for row in range(4): for col in range(4): if not constrained_matrix[row][col]: break all_candidates.append(constrained_matrix[row][col]) for candidate in itertools.product(*all_candidates): idx = 0 new_matrix = [[0] * 4 for _ in range(4)] for row in range(4): for col in range(4): new_matrix[row][col] = candidate[idx] idx += 1 enc_bytes = inverse_str_to_matrix(new_matrix) enc_bytes = cipher.decrypt(enc_bytes) enc = enc_bytes print(enc) # moectf{E@5Y_1eGendre_@nd_@ES*10} ","date":"2025-10-12T00:00:00Z","image":"http://localhost:1313/p/moectf-2025-crypto-wp/fengmian_hu_1d71e1ccdeb9af2d.png","permalink":"http://localhost:1313/p/moectf-2025-crypto-wp/","title":"MoeCTF 2025 Crypto WP"},{"content":"看看图片吧~\n","date":"2025-01-01T00:00:00Z","image":"http://localhost:1313/p/nothing/222_hu_b25c10edb3a96c27.png","permalink":"http://localhost:1313/p/nothing/","title":"nothing"},{"content":"看看图片吧~\n","date":"2025-01-01T00:00:00Z","image":"http://localhost:1313/p/nothing1/222_hu_ae62945159425a6b.png","permalink":"http://localhost:1313/p/nothing1/","title":"nothing1"}]